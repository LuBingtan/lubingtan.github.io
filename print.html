<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bingtan&#x27;s Wiki</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-e3a08c23.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-17b96cae.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Bingtan&#x27;s Wiki</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/lubingtan/lubingtan.github.io" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="latest-updates"><a href="#latest-updates" class="header">Latest updates</a></h1>
<h2 id="2026-01-09"><a class="header" href="#2026-01-09">2026-01-09</a></h2>
<blockquote>
<h4 id="docker环境配置"><a class="header" href="#docker环境配置"><a href="#docker环境配置-1">Docker环境配置</a></a></h4>
</blockquote>
<h2 id="2026-01-07"><a class="header" href="#2026-01-07">2026-01-07</a></h2>
<blockquote>
<h4 id="windows开发环境配置"><a class="header" href="#windows开发环境配置"><a href="#windows开发环境配置-1">WIndows开发环境配置</a></a></h4>
</blockquote>
<h2 id="2026-01-04"><a class="header" href="#2026-01-04">2026-01-04</a></h2>
<blockquote>
<h4 id="1_kubernetes概念"><a class="header" href="#1_kubernetes概念"><a href="#what-is-kubernetes">1_kubernetes概念</a></a></h4>
<h4 id="4_kube-scheduler源码分析"><a class="header" href="#4_kube-scheduler源码分析"><a href="#k8s-scheduler-源码分析">4_kube-scheduler源码分析</a></a></h4>
<h4 id="5_client-go-list--watch-原理"><a class="header" href="#5_client-go-list--watch-原理"><a href="docs/Cloud_Native/Kubernetes/5_client-go%20list%20&amp;%20watch%20原理.html">5_client-go list &amp; watch 原理</a></a></h4>
</blockquote>
<h2 id="2025-12-31"><a class="header" href="#2025-12-31">2025-12-31</a></h2>
<blockquote>
<h4 id="1-1_k8s工作负载"><a class="header" href="#1-1_k8s工作负载"><a href="#pod">1-1_k8s工作负载</a></a></h4>
<h4 id="2_kubernetes-api-server"><a class="header" href="#2_kubernetes-api-server"><a href="#2_kubernetes-api-server-1">2_kubernetes-api-server</a></a></h4>
<h4 id="6_service相关"><a class="header" href="#6_service相关"><a href="#what-is-kubernetes-service">6_service相关</a></a></h4>
<h4 id="cni详解"><a class="header" href="#cni详解"><a href="#cni详解-1">cni详解</a></a></h4>
<h4 id="flowschema"><a class="header" href="#flowschema"><a href="#flowschema-1">flowschema</a></a></h4>
<h4 id="k8s之pleg"><a class="header" href="#k8s之pleg"><a href="#k8s之pleg-1">k8s之pleg</a></a></h4>
<h4 id="kubelet原理"><a class="header" href="#kubelet原理"><a href="#kubelet-原理">kubelet原理</a></a></h4>
<h4 id="kubernetes_ha"><a class="header" href="#kubernetes_ha"><a href="#kubernetes_ha-1">kubernetes_ha</a></a></h4>
<h4 id="rbac"><a class="header" href="#rbac"><a href="#rbac-1">rbac</a></a></h4>
<h4 id="容器知识备忘录"><a class="header" href="#容器知识备忘录"><a href="#一份容器知识备忘录">容器知识备忘录</a></a></h4>
<h4 id="model-mesh-serving-一种可以大规模部署ml模型的解决方案"><a class="header" href="#model-mesh-serving-一种可以大规模部署ml模型的解决方案"><a href="docs/Machine_Learning/Inference/Model%20Mesh%20Serving:%20一种可以大规模部署ML模型的解决方案.html">Model Mesh Serving: 一种可以大规模部署ML模型的解决方案</a></a></h4>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pod"><a class="header" href="#pod">Pod</a></h1>
<h2 id="什么是pod"><a class="header" href="#什么是pod">什么是Pod</a></h2>
<p><em>Pod</em> 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。</p>
<p><em>Pod</em> （就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个） <a href="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers">容器</a>； 这些容器共享存储、网络、以及怎样运行这些容器的声明。 Pod 中的内容总是并置（colocated）的并且一同调度，在Pod的<strong>共享上下文中</strong>运行。</p>
<blockquote>
<p>Pod 的共享上下文包括一组 Linux 名字空间、控制组（cgroup）和可能一些其他的隔离 方面，即用来隔离 Docker 容器的技术。 在 Pod 的上下文中，每个独立的应用可能会进一步实施隔离。就 Docker 概念的术语而言，Pod 类似于共享名字空间和文件系统卷的一组 Docker 容器。</p>
</blockquote>
<p>Pod 所建模的是特定于应用的“逻辑主机”，其中包含一个或多个应用器， 这些容器是相对紧密的耦合在一起的。 在非云环境中，在相同的物理机或虚拟机上运行的应用类似于在同一逻辑主机上运行的云应用。</p>
<p>除了应用容器，Pod 还可以包含在 Pod 启动期间运行的 <a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/init-containers/">Init 容器</a>。 你也可以在集群中支持<a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/ephemeral-containers/">临时性容器</a> 的情况下，为调试的目的注入临时性容器。</p>
<h2 id="如何使用pod"><a class="header" href="#如何使用pod">如何使用Pod</a></h2>
<p>通常你不需要直接创建 Pod，甚至单实例 Pod。更多情况下，你会使用诸如 <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/">Deployment</a> 或 <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/job/">Job</a> 这类工作负载资源来创建 Pod。如果 Pod 需要跟踪状态， 可以考虑 <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a> 资源。</p>
<p>每个 Pod 都旨在运行给定应用程序的单个实例。如果希望横向扩展应用程序（例如，运行多个实例 以提供更多的资源），则应该使用多个 Pod，每个实例使用一个 Pod。 在 Kubernetes 中，这通常被称为 <em>副本（Replication）</em>。 通常使用一种工作负载资源及其<a href="https://kubernetes.io/zh/docs/concepts/architecture/controller/">控制器</a> 来创建和管理一组 Pod 副本。</p>
<h3 id="pod与容器的关系"><a class="header" href="#pod与容器的关系">Pod与容器的关系</a></h3>
<p>Pod中可以包括一个或者多个容器，按照Pod 中容器的数量，Pod使用方式可以分为两种：</p>
<ul>
<li><strong>运行单个容器的 Pod</strong>。“一个Pod, 一个容器“模型是最常见的 Kubernetes 用例； 在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。</li>
<li><strong>运行多个协同工作的容器的 Pod</strong>。 Pod 可能封装由多个紧密耦合且需要共享资源的共处容器组成的应用程序。 这些位于同一位置的容器可能形成单个内聚的服务单元 —— 一个容器将文件从共享卷提供给公众， 而另一个单独的“挂斗”（sidecar）容器则刷新或更新这些文件。 Pod 将这些容器和存储资源打包为一个可管理的实体。</li>
</ul>
<blockquote>
<p>说明：将多个并置、同管的容器组织到一个 Pod 中是一种相对高级的使用场景。 只有在一些场景中，容器之间紧密关联时你才应该使用这种模式。</p>
</blockquote>
<p>当Pod中有多个容器时，Pod 中的容器被自动安排到集群中的同一物理机或虚拟机上，并可以一起进行调度。 容器之间可以共享资源和依赖、彼此通信、协调何时以及何种方式终止自身</p>
<p><strong>例如</strong>，你可能有一个容器，为共享卷中的文件提供 Web 服务器支持，以及一个单独的 “sidecar（挂斗）”容器负责从远端更新这些文件。</p>
<p>另外，有些 Pod 具有 <a href="https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-init-container">Init 容器</a> ， Init 容器会在启动应用容器之前运行并完成。</p>
<h3 id="pod与工作负载"><a class="header" href="#pod与工作负载">Pod与工作负载</a></h3>
<p>kubernets提供了一些Pod之上的工作负载，例如Deployment、Job、Daemonset等等。</p>
<p>你可以使用工作负载资源来创建和管理多个 Pod。工作负载资源的控制器能够处理副本的管理、上线，并在 Pod 失效时提供自愈能力。 例如，如果一个节点失败，控制器注意到该节点上的 Pod 已经停止工作， 就可以创建替换性的 Pod。调度器会将替身 Pod 调度到一个健康的节点执行。</p>
<p>工作负载的控制器会使用负载对象中的 <code>PodTemplate</code> 来生成实际的 Pod。 <code>PodTemplate</code> 是你用来运行应用时指定的负载资源的目标状态的一部分。需要注意的是，<strong>修改 Pod 模版</strong>或者切换到新的 Pod 模版都<strong>不会对已经存在的 Pod 起作用</strong>。 Pod 不会直接收到模版的更新。相反， 新的 Pod 会被创建出来，与更改后的 Pod 模版匹配。</p>
<p><strong>例如</strong>，Deployment 控制器针对每个 Deployment 对象确保运行中的 Pod 与当前的 Pod 模版匹配。如果模版被更新，则 Deployment 必须删除现有的 Pod，基于更新后的模版创建新的 Pod。每个工作负载资源都实现了自己的规则，用来处理对 Pod 模版的更新。</p>
<h3 id="pod的更新与替换"><a class="header" href="#pod的更新与替换">Pod的更新与替换</a></h3>
<p>正如前面章节所述，当某工作负载的 Pod 模板被改变时，控制器会基于更新的模板 创建新的 Pod 对象而不是对现有 Pod 执行更新或者修补操作。</p>
<p>Kubernetes 并不禁止你直接管理 Pod。对运行中的 Pod 的某些字段执行就地更新操作 还是可能的。不过，类似 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#patch-pod-v1-core"><code>patch</code></a> 和 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#replace-pod-v1-core"><code>replace</code></a> 这类更新操作有一些限制：</p>
<ul>
<li>Pod 的绝大多数元数据都是不可变的。例如，你不可以改变其 <code>namespace</code>、<code>name</code>、 <code>uid</code> 或者 <code>creationTimestamp</code> 字段；<code>generation</code> 字段是比较特别的，如果更新 该字段，只能增加字段取值而不能减少。</li>
<li>如果 <code>metadata.deletionTimestamp</code> 已经被设置，则不可以向 <code>metadata.finalizers</code> 列表中添加新的条目。</li>
<li>Pod 更新不可以改变除 <code>spec.containers[*].image</code>、<code>spec.initContainers[*].image</code>、 <code>spec.activeDeadlineSeconds</code> 或 <code>spec.tolerations</code> 之外的字段。 对于 <code>spec.tolerations</code>，你只被允许添加新的条目到其中。</li>
<li>在更新<code>spec.activeDeadlineSeconds</code> 字段时，以下两种更新操作是被允许的：
<ol>
<li>如果该字段尚未设置，可以将其设置为一个正数；</li>
<li>如果该字段已经设置为一个正数，可以将其设置为一个更小的、非负的整数</li>
</ol>
</li>
</ul>
<h3 id="pod资源共享与通信"><a class="header" href="#pod资源共享与通信">Pod资源共享与通信</a></h3>
<p>Pod 使它的成员容器间能够进行数据共享和通信。</p>
<h4 id="存储"><a class="header" href="#存储">存储</a></h4>
<p>一个 Pod 可以设置一组共享的存储<a href="https://kubernetes.io/zh/docs/concepts/storage/volumes/">卷</a>。 Pod 中的所有容器都可以访问该共享卷，从而允许这些容器共享数据。 卷还允许 Pod 中的持久数据保留下来，即使其中的容器需要重新启动。 有关 Kubernetes 如何在 Pod 中实现共享存储并将其提供给 Pod 的更多信息， 请参考<a href="https://kubernetes.io/zh/docs/concepts/storage/">卷</a>。</p>
<h4 id="网络"><a class="header" href="#网络">网络</a></h4>
<p>每个 Pod 都在每个地址族中获得一个唯一的 IP 地址。 Pod 中的每个容器共享网络名字空间，包括 IP 地址和网络端口。 <em>Pod 内</em> 的容器可以使用 <code>localhost</code> 互相通信。 当 Pod 中的容器与 <em>Pod 之外</em> 的实体通信时，它们必须协调如何使用共享的网络资源 （例如端口）。</p>
<p>他们也能通过如 <strong>SystemV 信号量</strong>或 <strong>POSIX 共享内存</strong>这类标准的进程间通信方式互相通信。 不同 Pod 中的容器的 IP 地址互不相同，没有 <a href="https://kubernetes.io/zh/docs/concepts/policy/pod-security-policy/">特殊配置</a> 就不能使用 IPC 进行通信。 如果某容器希望与运行于其他 Pod 中的容器通信，可以通过 IP 联网的方式实现。</p>
<p>Pod 中的容器所看到的系统主机名与为 Pod 配置的 <code>name</code> 属性值相同。 <a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/networking/">网络</a>部分提供了更多有关此内容的信息。</p>
<h3 id="pod的容器权限"><a class="header" href="#pod的容器权限">Pod的容器权限</a></h3>
<p>Pod 中的任何容器都可以使用容器规约中的 <a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/security-context/">安全性上下文</a>中的 <code>privileged</code> 参数启用特权模式。 这对于想要使用操作系统管理权能（Capabilities，如操纵网络堆栈和访问设备） 的容器很有用。 容器内的进程几乎可以获得与容器外的进程相同的特权。</p>
<blockquote>
<p><strong>说明：</strong> 你的<a href="https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes">容器运行时</a>必须支持 特权容器的概念才能使用这一配置。</p>
</blockquote>
<h3 id="静态pod"><a class="header" href="#静态pod">静态Pod</a></h3>
<p><em>静态 Pod（Static Pod）</em> 直接由特定节点上的 <code>kubelet</code> 守护进程管理， 不需要<a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-apiserver/">API 服务器</a>看到它们。 尽管大多数 Pod 都是通过控制面（例如，<a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/">Deployment</a>） 来管理的，对于静态 Pod 而言，<code>kubelet</code> 直接监控每个 Pod，并在其失效时重启之。</p>
<p>静态 Pod 通常绑定到某个节点上的 <a href="https://kubernetes.io/docs/reference/generated/kubelet">kubelet</a>。 其主要用途是运行自托管的控制面。 在自托管场景中，使用 <code>kubelet</code> 来管理各个独立的 <a href="https://kubernetes.io/zh/docs/concepts/overview/components/#control-plane-components">控制面组件</a>。</p>
<p><code>kubelet</code> 自动尝试为每个静态 Pod 在 Kubernetes API 服务器上创建一个 <a href="https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-mirror-pod">镜像 Pod</a>。 这意味着在节点上运行的 Pod 在 API 服务器上是可见的，但不可以通过 API 服务器来控制。</p>
<h3 id="pod-lifecicle"><a class="header" href="#pod-lifecicle">Pod Lifecicle</a></h3>
<p>Pod 遵循一个预定义的生命周期，起始于 <code>Pending</code> <a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase">阶段</a>，如果至少 其中有一个主要容器正常启动，则进入 <code>Running</code>，之后取决于 Pod 中是否有容器以 失败状态结束而进入 <code>Succeeded</code> 或者 <code>Failed</code> 阶段。</p>
<p>在 Pod 运行期间，<code>kubelet</code> 能够重启容器以处理一些失效场景。 在 Pod 内部，Kubernetes 跟踪不同容器的<a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#container-states">状态</a> 并确定使 Pod 重新变得健康所需要采取的动作。</p>
<p>在 Kubernetes API 中，Pod 包含规约部分和实际状态部分。 Pod 对象的状态包含了一组 <a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions">Pod 状况（Conditions）</a>。 如果应用需要的话，你也可以向其中注入<a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate">自定义的就绪性信息</a>。</p>
<p>Pod 在其生命周期中只会被<a href="https://kubernetes.io/zh/docs/concepts/scheduling-eviction/">调度</a>一次。 一旦 Pod 被调度（分派）到某个节点，Pod 会一直在该节点运行，直到 Pod 停止或者 被<a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination">终止</a>。</p>
<h4 id="pod-lifetime"><a class="header" href="#pod-lifetime">Pod Lifetime</a></h4>
<p>和一个个独立的应用容器一样，Pod 也被认为是相对临时性（而不是长期存在）的实体。 Pod 会被创建、赋予一个唯一的 ID（<a href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/names/#uids">UID</a>）， 并被调度到节点，并在终止（根据重启策略）或删除之前一直运行在该节点。</p>
<p>如果一个<a href="https://kubernetes.io/zh/docs/concepts/architecture/nodes/">节点</a>死掉了，调度到该节点 的 Pod 也被计划在给定超时期限结束后<a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection">删除</a>。</p>
<p>Pod 自身不具有自愈能力。如果 Pod 被调度到某<a href="https://kubernetes.io/zh/docs/concepts/architecture/nodes/">节点</a> 而该节点之后失效，或者调度操作本身失效，Pod 会被删除；与此类似，Pod 无法在节点资源 耗尽或者节点维护期间继续存活。Kubernetes 使用一种高级抽象，称作 <a href="https://kubernetes.io/zh/docs/concepts/architecture/controller/">控制器</a>，来管理这些相对而言 可随时丢弃的 Pod 实例。</p>
<p>任何给定的 Pod （由 UID 定义）从不会被“重新调度（rescheduled）”到不同的节点； 相反，这一 Pod 可以被一个新的、几乎完全相同的 Pod 替换掉。 如果需要，新 Pod 的名字可以不变，但是其 UID 会不同。</p>
<p>如果某物声称其生命期与某 Pod 相同，例如存储<a href="https://kubernetes.io/zh/docs/concepts/storage/volumes/">卷</a>， 这就意味着该对象在此 Pod （UID 亦相同）存在期间也一直存在。 如果 Pod 因为任何原因被删	除，甚至某完全相同的替代 Pod 被创建时， 这个相关的对象（例如这里的卷）也会被删除并重建。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="what-is-kubernetes"><a class="header" href="#what-is-kubernetes"><strong>What</strong> is Kubernetes</a></h1>
<p><a href="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/">官方文档</a>：</p>
<p>Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。</p>
<h1 id="why-use-kubernetes"><a class="header" href="#why-use-kubernetes"><strong>Why</strong> use Kubernetes</a></h1>
<h2 id="应用部署方式的发展历史"><a class="header" href="#应用部署方式的发展历史"><strong>应用部署方式的发展历史</strong></a></h2>
<p>传统应用发展到现在已经经历了多种部署架构：</p>
<p><img src="https://i.loli.net/2021/04/12/OBgi7ILtbCcGv6F.png" alt="image-20210411153212606"></p>
<p><strong>传统部署时代</strong>：</p>
<p>早期应用都是直接部署在物理服务器，无法为应用程序定义资源边界，从而引起多个应用之间的资源分配问题。 例如，如果在物理机上运行多个应用程序，由于其中一个应用程序占用了大部分资源， 导致其他应用程序性能下降。 有一个解决方案是，把每个应用程序放在不同的服务器上，其存在的问题是，在进行横向扩展时无法充分利用服务器资源， 并且维护多个物理机的成本很高。</p>
<p><strong>虚拟化部署时代</strong>：</p>
<p>针对传统部署中出现的问题，引入了虚拟化解决方案。虚拟化技术允许在单个物理机的 上运行多个虚拟机（VM）。 虚拟化可以隔离位于不同 VM中的应用程序，并提供一定程度的安全，不同VM之间不能由应用程序直接访问。</p>
<p>虚拟化技术能够更好地利用物理服务器上的资源，并且由于可轻松地添加或更新应用程序，从而实现更好的可伸缩性，降低硬件成本等等。</p>
<p>每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。</p>
<p><strong>容器部署时代</strong>：</p>
<p>容器类似于 VM，但是与VM相比隔离性较低，操作系统（OS）在应用程序之间是被共享的。 因此，容器被认为是轻量级的虚拟机。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。</p>
<p>容器因具有许多优势而变得流行起来。下面列出的是容器的一些好处：</p>
<ul>
<li>敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。</li>
<li>持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性），支持可靠且频繁的容器镜像构建和部署。</li>
<li>关注开发与运维的分离：在构建/发布时而不是在部署时创建应用程序容器镜像， 从而将应用程序与基础架构分离。</li>
<li>可观察性：不仅可以观测OS级别的信息和指标，还可以显示应用程序的健康状态以及其它指标。</li>
<li>开发、测试以及生产环境的一致性：PC与云端保持统一的运行方式。</li>
<li>跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。</li>
<li>以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。</li>
<li>松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分，并且可以动态部署和管理，而不是在一台大型单机上整体运行。</li>
<li>资源隔离：可预测的应用程序性能。</li>
<li>资源利用：高效率和高密度。</li>
</ul>
<h2 id="kubernetes--提供的功能"><a class="header" href="#kubernetes--提供的功能">Kubernetes  提供的功能</a></h2>
<p>Kubernetes 为你提供：</p>
<ul>
<li><strong>服务发现和负载均衡</strong>：Kubernetes 可以通过DNS 或IP 地址的方式暴露容器。如果进入容器的流量很大， Kubernetes 可以负载均衡并分发网络流量，从而使部署稳定。</li>
<li><strong>存储编排</strong>：Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公有云存储服务以及其它更多存储方式。</li>
<li><strong>自动部署和回滚</strong>：你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态更改为期望状态。例如，你可以令Kubernetes自动化地为你的部署创建新容器，删除现有容器并将它们的所有资源用于新容器。</li>
<li><strong>Automatic bin packing</strong>：Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。</li>
<li><strong>自我修复</strong>：Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</li>
<li><strong>密钥与配置管理</strong>：Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</li>
</ul>
<h2 id="kubernetes--不能提供的功能"><a class="header" href="#kubernetes--不能提供的功能">Kubernetes  不能提供的功能</a></h2>
<p>Kubernetes 不是传统的、包罗万象的 PaaS（平台即服务）系统。 由于 Kubernetes 在容器级别而不是在硬件级别运行，它提供了 PaaS 产品共有的一些普遍适用的功能， 例如部署、扩展、负载均衡、日志记录和监视。 但是，Kubernetes 不是单体系统，默认解决方案都是可选和可插拔的。 Kubernetes 提供了构建开发人员平台的基础，但是在重要的地方保留了用户的选择和灵活性。</p>
<p>Kubernetes：</p>
<ul>
<li>
<p>不限制支持的应用程序类型。 Kubernetes 旨在支持极其多种多样的工作负载，包括无状态、有状态和数据处理工作负载。 如果应用程序可以在容器中运行，那么它应该可以在 Kubernetes 上很好地运行。</p>
</li>
<li>
<p>不部署源代码，也不构建你的应用程序。 持续集成(CI)、交付和部署（CI/CD）工作流取决于组织的文化和偏好以及技术要求。</p>
</li>
<li>
<p>不提供应用程序级别的服务作为内置服务，例如中间件（例如，消息中间件）、 数据处理框架（例如，Spark）、数据库（例如，mysql）、缓存、集群存储系统 （例如，Ceph）。这样的组件可以在 Kubernetes 上运行，并且/或者可以由运行在 Kubernetes 上的应用程序通过可移植机制（例如， <a href="https://openservicebrokerapi.org/">开放服务代理</a>）来访问。</p>
</li>
<li>
<p>不要求日志记录、监视或警报解决方案。 它提供了一些集成作为概念证明，并提供了收集和导出指标的机制。</p>
</li>
<li>
<p>不提供或不要求配置语言/系统（例如 jsonnet），它提供了声明性 API， 该声明性 API 可以由任意形式的声明性规范所构成。</p>
</li>
<li>
<p>不提供也不采用任何全面的机器配置、维护、管理或自我修复系统。</p>
</li>
<li>
<p>此外，Kubernetes 不仅仅是一个编排系统，实际上它消除了编排的需要。 <strong>编排的技术定义</strong>是<strong>执行已定义的工作流程：首先执行 A，然后执行 B，再执行 C</strong>。 相比之下，Kubernetes 包含一组独立的、可组合的控制过程， 这些过程连续地将当前状态驱动到所提供的所需状态。 如何从 A 到 C 的方式无关紧要，也不需要集中控制，这使得系统更易于使用 且功能更强大、系统更健壮、更为弹性和可扩展</p>
</li>
</ul>
<h1 id="how-kubernetes-works"><a class="header" href="#how-kubernetes-works"><strong>How</strong> Kubernetes works</a></h1>
<p>当你部署完 Kubernetes, 即拥有了一个完整的集群。</p>
<p>一个 Kubernetes 集群由一组被称作节点的机器组成。这些节点上运行 Kubernetes 所管理的容器化应用。集群具有至少一个工作节点。</p>
<p>工作节点托管作为应用负载的组件的 Pod 。控制平面管理集群中的工作节点和 Pod 。 为集群提供故障转移和高可用性，这些控制平面一般跨多主机运行，集群跨多个节点运行。</p>
<p>本文档概述了交付正常运行的 Kubernetes 集群所需的各种组件。</p>
<p>这张图表展示了包含所有相互关联组件的 Kubernetes 集群。</p>
<p><img src="https://i.loli.net/2021/04/13/Is3cyY1nM7ZVPm2.png" alt="image-20210411160945780"></p>
<h2 id="kubernetes架构"><a class="header" href="#kubernetes架构">Kubernetes架构</a></h2>
<h3 id="控制面组件control-plane-components"><a class="header" href="#控制面组件control-plane-components">控制面组件(Control Plane Components)</a></h3>
<p>控制平面的组件对集群做出全局决策(比如调度)，以及检测和响应集群事件（例如，当不满足部署的 <code>replicas</code> 字段时，启动新的 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">pod</a>）。</p>
<p>控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件，并且不会在此计算机上运行用户容器。 请参阅<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/high-availability/">构建高可用性集群</a> 中对于多主机 VM 的设置示例。</p>
<h4 id="kube-apiserver"><a class="header" href="#kube-apiserver">kube-apiserver</a></h4>
<p>apiserver是Kubernetes的控制面组件，它暴露了Kubernetes的API。apiserver也是Kubernetes的控制面前端。</p>
<p>Kubernetes API 服务器的主要实现是 <a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-apiserver/">kube-apiserver</a>。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些<strong>实例之间平衡流量</strong></p>
<h4 id="etcd"><a class="header" href="#etcd">etcd</a></h4>
<p>etcd是拥有一致性以及高可用性的KV数据库，在kubernets中etcd被用于保存所有集群数据的后端存储。</p>
<p>在实际应用中，通常需要对etcd进行备份。</p>
<h4 id="kube-scheduler"><a class="header" href="#kube-scheduler">kube-scheduler</a></h4>
<p>控制平面中调度器组件，负责监视新创建的、未指定运行<a href="https://kubernetes.io/zh/docs/concepts/architecture/nodes/">节点（node）</a>的 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pods</a>，选择节点让 Pod 在上面运行。</p>
<p>调度决策考虑的因素包括，单个 Pod 和 Pod 集合的资源需求、硬约束/软约束/策略约束，亲和性和反亲和性spec、数据位置、工作负载间的干扰和最后时限。</p>
<h4 id="kube-controller-manger"><a class="header" href="#kube-controller-manger">kube-controller-manger</a></h4>
<p>控制平面中的<a href="https://kubernetes.io/zh/docs/concepts/architecture/controller/">控制器</a> 的组件。</p>
<p>从逻辑上讲，每个<a href="https://kubernetes.io/zh/docs/concepts/architecture/controller/">控制器</a>都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。</p>
<p>这些控制器包括:</p>
<ul>
<li><strong>节点控制器</strong>（Node Controller）: 负责在节点出现故障时进行通知和响应</li>
<li><strong>任务控制器</strong>（Job controller）: 监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li>
<li><strong>端点控制器</strong>（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)</li>
<li><strong>服务帐户和令牌控制器</strong>（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌</li>
</ul>
<h4 id="cloud-controller-manger"><a class="header" href="#cloud-controller-manger">cloud-controller-manger</a></h4>
<p>cloud-controller-manger是能够嵌入指定云的控制逻辑的组件，能够将自己的集群链接到云服务商。并且能够分离两种组件，两种组件分别是“与云服务交互的组件“，以及“与自己的集群交互的组件“。</p>
<p><code>cloud-controller-manager</code> 仅用于特定云平台的控制回路。 如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器。</p>
<p>与 <code>kube-controller-manager</code> 类似，<code>cloud-controller-manager</code> 将若干逻辑上独立的 控制回路组合到同一个可执行文件中，供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。</p>
<p>下面的控制器都包含对云平台驱动的依赖：</p>
<ul>
<li>节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除</li>
<li>路由控制器（Route Controller）: 用于在底层云基础架构中设置路由</li>
<li>服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器</li>
</ul>
<h3 id="节点组件node-components"><a class="header" href="#节点组件node-components">节点组件（Node Components）</a></h3>
<h4 id="kubelet"><a class="header" href="#kubelet">kubelet</a></h4>
<p>一个在集群中每个<a href="https://kubernetes.io/zh/docs/concepts/architecture/nodes/">节点（node）</a>上运行的代理。 它保证<a href="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers">容器（containers）</a>都 运行在 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a> 中。</p>
<p>kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。</p>
<h4 id="kube-proxy"><a class="header" href="#kube-proxy">kube-proxy</a></h4>
<p><a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a> 是集群中每个节点上运行的网络代理， 实现 Kubernetes <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/">服务（Service）</a> 概念的一部分。</p>
<p>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p>
<p>如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则，kube-proxy 仅转发流量本身。</p>
<h4 id="容器运行时container-runtime"><a class="header" href="#容器运行时container-runtime">容器运行时（Container Runtime）</a></h4>
<p>容器运行环境是负责运行容器的软件。</p>
<p>Kubernetes 支持多个容器运行环境: <a href="https://kubernetes.io/zh/docs/reference/kubectl/docker-cli-to-kubectl/">Docker</a>、 <a href="https://containerd.io/docs/">containerd</a>、<a href="https://cri-o.io/#what-is-cri-o">CRI-O</a> 以及任何实现 <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md">Kubernetes CRI (容器运行环境接口)</a>。</p>
<h3 id="插件addons"><a class="header" href="#插件addons">插件（Addons）</a></h3>
<p>插件使用 Kubernetes 资源（<a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a>、 <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/">Deployment</a>等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 <code>kube-system</code> 命名空间。</p>
<p>下面描述众多插件中的几种。有关可用插件的完整列表，请参见 <a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/addons/">插件（Addons）</a></p>
<h4 id="dns"><a class="header" href="#dns">DNS</a></h4>
<p>尽管其他插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该 有<a href="https://kubernetes.io/zh/docs/concepts/services-networking/dns-pod-service/">集群 DNS</a>， 因为很多示例都需要 DNS 服务。</p>
<p>集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。</p>
<p>Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。</p>
<h4 id="web界面dashboard"><a class="header" href="#web界面dashboard">Web界面（dashboard）</a></h4>
<p><a href="https://kubernetes.io/zh/docs/tasks/access-application-cluster/web-ui-dashboard/">Dashboard</a> 是Kubernetes 集群的通用的、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身并进行故障排除</p>
<h4 id="容器资源监控"><a class="header" href="#容器资源监控">容器资源监控</a></h4>
<p><a href="https://kubernetes.io/zh/docs/tasks/debug-application-cluster/resource-usage-monitoring/">容器资源监控</a> 将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供用于浏览这些数据的界面。</p>
<h4 id="集群级别的日志"><a class="header" href="#集群级别的日志">集群级别的日志</a></h4>
<p><a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/logging/">集群层面日志</a> 机制负责将容器的日志数据 保存到一个集中的日志存储中，该存储能够提供搜索和浏览接口。</p>
<h2 id="kubernetesapi"><a class="header" href="#kubernetesapi">KubernetesAPI</a></h2>
<p>Kubernetes <a href="https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-control-plane">控制面</a> 的核心是 <a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-apiserver/">API 服务器</a>。 API 服务器负责提供 HTTP API，以供用户、集群中的不同部分和集群外部组件相互通信。</p>
<p>Kubernetes API 使你可以查询和操纵 Kubernetes API 中对象（例如：Pod、Namespace、ConfigMap 和 Event）的状态。</p>
<p>大部分操作都可以通过 <a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/">kubectl</a> 命令行接口或 类似 <a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/">kubeadm</a> 这类命令行工具来执行， 这些工具在背后也是调用 API。不过，你也可以使用 REST 调用来访问这些 API。</p>
<p>如果你正在编写程序来访问 Kubernetes API，可以考虑使用 <a href="https://kubernetes.io/zh/docs/reference/using-api/client-libraries/">客户端库</a>之一。</p>
<h3 id="openapi-规范"><a class="header" href="#openapi-规范">OpenAPI 规范</a></h3>
<p>完整的 API 细节是用 <a href="https://www.openapis.org/">OpenAPI</a> 来表述的。</p>
<p>Kubernetes API 服务器通过 <code>/openapi/v2</code> 末端提供 OpenAPI 规范。 你可以按照下表所给的请求头部，指定响应的格式：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>头部</th><th>可选值</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td><code>Accept-Encoding</code></td><td><code>gzip</code></td><td><em>不指定此头部也是可以的</em></td></tr>
<tr><td><code>Accept</code></td><td><code>application/com.github.proto-openapi.spec.v2@v1.0+protobuf</code></td><td><em>主要用于集群内部</em></td></tr>
<tr><td><code>application/json</code></td><td><em>默认值</em></td><td></td></tr>
<tr><td><code>*</code></td><td><em>提供</em><code>application/json</code></td><td></td></tr>
</tbody>
</table>
</div>
<p>Kubernetes 为 API 实现了一种基于 Protobuf 的序列化格式，主要用于集群内部通信。 关于此格式的详细信息，可参考 <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/protobuf.md">Kubernetes Protobuf 序列化</a> 设计提案。每种模式对应的接口描述语言（IDL）位于定义 API 对象的 Go 包中</p>
<h3 id="api变更"><a class="header" href="#api变更">API变更</a></h3>
<p>Kubernetes的<a href="https://kubernetes.io/zh/docs/reference/using-api/deprecation-policy/">API废弃策略</a></p>
<p>贡献者在变更API时可以参考<a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api_changes.md#readme">API变更</a></p>
<h3 id="api组和版本"><a class="header" href="#api组和版本">API组和版本</a></h3>
<p>Kubernetes 支持多个 API 版本， 每一个版本都在不同 API 路径下，例如 <code>/api/v1</code> 或<code>/apis/rbac.authorization.k8s.io/v1alpha1</code>。</p>
<h3 id="api扩展"><a class="header" href="#api扩展">API扩展</a></h3>
<p>有两种途径来扩展 Kubernetes API：</p>
<ol>
<li>你可以使用<a href="https://kubernetes.io/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/">自定义资源</a> 来以声明式方式定义 API 服务器如何提供你所选择的资源 API。</li>
<li>你也可以选择实现自己的 <a href="https://kubernetes.io/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/">聚合层</a> 来扩展 Kubernetes API。</li>
</ol>
<h2 id="kubernetes对象object"><a class="header" href="#kubernetes对象object">Kubernetes对象（Object）</a></h2>
<h3 id="what-is-kubernetes-object"><a class="header" href="#what-is-kubernetes-object"><strong>What</strong> is Kubernetes Object</a></h3>
<p>Kubernetes Object可以理解为REST API中的<em>资源</em>。可以通过Kubernetes API对Object进行创建、修改、更新、删除等操作。</p>
<p>在Kubernetes 中，Kubernetes Object代表了对Kubernetes系统状态的描述，例如：</p>
<ul>
<li>哪些容器化应用在运行（以及在哪些节点上）</li>
<li>可以被应用使用的资源</li>
<li>关于应用运行时表现的策略，比如重启策略、升级策略，以及容错策略</li>
</ul>
<p>可以将Kubernetes 对象视为一种<strong>声明式编程</strong>，Kubernetes 对象描述了一种<strong>目标</strong>。创建对象的过程，本质上是在告知 Kubernetes 系统，用户所需要的工作负载看起来是什么样子的， 这就是 Kubernetes 集群的 <strong>期望状态（Desired State）</strong>。</p>
<h3 id="kubernetes-对象的结构"><a class="header" href="#kubernetes-对象的结构">Kubernetes 对象的结构</a></h3>
<p>每种 Kubernetes 对象都有自己的结构，举个例子，Deployment对象有如下结构（yaml格式）：</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  namespace: default
  labels:
    environment: production
    app: nginx
  annotations:
    imageregistry: "https://hub.docker.com/"
spec:
  selector:
  matchLabels:
    component: redis
  matchExpressions:
    - {key: tier, operator: In, values: [cache]}
    - {key: environment, operator: NotIn, values: [dev]}
  replicas: 2 # tells deployment to run 2 pods matching the template
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
       image: nginx:1.14.2
        ports:
        - containerPort: 80
</code></pre>
<p>每个Kubernetes 对象都拥有如下字段。</p>
<h4 id="apiversion"><a class="header" href="#apiversion">apiVersion</a></h4>
<p>对象的<strong>分组</strong>以及<strong>版本</strong></p>
<h4 id="kind"><a class="header" href="#kind">kind</a></h4>
<p>对象的种类</p>
<h4 id="metadata"><a class="header" href="#metadata">metadata</a></h4>
<p>对象的<strong>标识</strong>，包括name、namespace、uid、labels等等</p>
<ul>
<li>
<p><strong>name</strong>作为资源名称，name的命名规范需要 符合<strong>DNS子域名</strong>以及<strong>DNS标签名</strong>的规范（详见：<a href="https://tools.ietf.org/html/rfc1123">RFC-1123</a>）。</p>
<ul>
<li>不能超过253个字符</li>
<li>只能包含小写字母、数字，以及’-’</li>
<li>须以字母数字开头</li>
<li>须以字母数字结尾</li>
</ul>
</li>
<li>
<p><strong>namespace</strong>：名字空间为资源提供了一个<strong>分组范围</strong>。</p>
<ul>
<li>
<p>资源的名称需要在名字空间内是唯一的。</p>
</li>
<li>
<p>名字空间不能相互嵌套，每个 Kubernetes 资源只能在一个名字空间中。</p>
</li>
<li>
<p>通过namespace可以划分资源（通过<a href="https://kubernetes.io/zh/docs/concepts/policy/resource-quotas/">资源配额</a>）</p>
</li>
<li>
<p>初始的四个空间：defaut、kube-node-lease、kube-system、kube-public</p>
<blockquote>
<ul>
<li><code>default</code> 没有指明使用其它名字空间的对象所使用的默认名字空间</li>
<li><code>kube-system</code> Kubernetes 系统创建对象所使用的名字空间</li>
<li><code>kube-public</code> 这个名字空间是自动创建的，所有用户（包括未经过身份验证的用户）都可以读取它。 这个名字空间主要用于集群使用，以防某些资源在整个集群中应该是可见和可读的。 这个名字空间的公共方面只是一种约定，而不是要求。</li>
<li><code>kube-node-lease</code> 此名字空间用于与各个节点相关的租期（Lease）对象； 此对象的设计使得集群规模很大时节点心跳检测性能得到提升</li>
</ul>
</blockquote>
</li>
<li>
<p>DNS支持：当创建一个<a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/">Service</a> 时， Kubernetes 会创建一个相应的 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/dns-pod-service/">DNS 条目</a>，该条目的形式是 <code>&lt;服务名称&gt;.&lt;名字空间名称&gt;.svc.cluster.local</code></p>
</li>
<li>
<p>有些资源没有namespace字段，如节点（Node）、持久化卷</p>
</li>
</ul>
</li>
<li>
<p><strong>labels</strong>：资源上附加的KV键值对，可以作为自定义的<strong>资源属性</strong>。</p>
<ul>
<li>
<p><strong>键的格式</strong>：<code>&lt;前缀段&gt;/&lt;名称段&gt;</code></p>
<ul>
<li><strong>名称段</strong>格式：名称段是必须有的，必须小于等于 63 个字符，以字母数字字符（<code>[a-z0-9A-Z]</code>）开头和结尾， 带有破折号（<code>-</code>），下划线（<code>_</code>），点（ <code>.</code>）和之间的字母数字。</li>
<li><strong>前缀段</strong>格式：前缀必须符合 <strong>DNS 子域格式</strong>：由点（<code>.</code>）分隔的一系列 <strong>DNS 标签</strong>，总共不超过 253 个字符， 后跟斜杠（<code>/</code>）</li>
<li><strong>前缀段</strong>可以省略：如果省略前缀，则默认该标签键是用户所私有。Kubernetes中的自动化组件（如scheduler、controller-manger以及第三方组件）<strong>必须使用前缀</strong>。另外，<code>kubernetes.io/</code> 前缀是为 Kubernetes 核心组件保留的。</li>
</ul>
</li>
<li>
<p><strong>值的格式</strong>：</p>
<ul>
<li>必须为 63 个字符或更少</li>
<li>必须为空或以字母数字字符（<code>[a-z0-9A-Z]</code>）开头和结尾</li>
<li>中间可以包含破折号（<code>-</code>）、下划线（<code>_</code>）、点（<code>.</code>）和字母或数字。</li>
</ul>
</li>
<li>
<p><strong>Label选择器</strong>：Kubernetes API（List、Watch）支持通过 label 选择运算符来对资源进行过滤，例如 <code>environment=production,app!=test</code>。支持的运算符有：<code>==</code>, <code>!=</code>, <code>in</code>, <code>notin</code>, <code>exists</code></p>
</li>
<li>
<p><strong>资源Selector定义</strong>：对于某些资源，它将视另外一些资源为子资源，进而进行管理（例如Deployment与Pod）。对于这些资源，也支持通过Label选择器来选择指定的子资源</p>
</li>
</ul>
</li>
<li>
<p><strong>annotations</strong>：资源上附加的KV键值对，可以作为<strong>资源元数据</strong>。</p>
<ul>
<li>格式：<strong>键的格式</strong>与labels相同，值的格式没有限制。</li>
<li>与labels不同，注解不用于标识和选择对象。 注解中的元数据，可以很小，也可以很大，可以是结构化的，也可以是非结构化的，能够包含标签不允许的字符。例如：指向日志、监控的地址，构建、发布的信息（时间戳、Git分支等），负责人的电话。</li>
</ul>
</li>
</ul>
<h4 id="spec和status"><a class="header" href="#spec和status">spec和status</a></h4>
<p>spec 是对 Kubernetes Object <strong>期望状态</strong>的描述，status 是 Kubernetes Object <strong>当前状态</strong>的描述。</p>
<p>Kubernetes 的控制面会管理Object，使它的当前状态与期望状态相匹配。更多的可以查看 <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md">Kubernetes API 约定</a></p>
<h3 id="kubernetes对象的工作方式"><a class="header" href="#kubernetes对象的工作方式">Kubernetes对象的工作方式</a></h3>
<h4 id="用户侧管理"><a class="header" href="#用户侧管理">用户侧管理</a></h4>
<ul>
<li>可以使用 <code>kubectl</code> 命令行工具，支持多种不同的方式来创建和管理 Kubernetes 对象</li>
<li>可以使用sdk，如client-go</li>
</ul>
<h4 id="控制面管理"><a class="header" href="#控制面管理">控制面管理</a></h4>
<ul>
<li>控制平面</li>
<li>控制平面的扩展（第三方组件）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="2_kubernetes-api-server-1"><a href="#2_kubernetes-api-server-1" class="header">2_kubernetes-api-server</a></h1>
<h2 id="理解-kubernetes-证书"><a class="header" href="#理解-kubernetes-证书">理解 Kubernetes 证书</a></h2>
<h3 id="rsa-加密与-ssl-协议"><a class="header" href="#rsa-加密与-ssl-协议">RSA 加密与 SSL 协议</a></h3>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="k8s-scheduler-源码分析"><a class="header" href="#k8s-scheduler-源码分析">k8s scheduler 源码分析</a></h1>
<h2 id="scheduler-基本工作流程"><a class="header" href="#scheduler-基本工作流程">Scheduler 基本工作流程</a></h2>
<h3 id="配置初始化"><a class="header" href="#配置初始化">配置初始化</a></h3>
<h4 id="三种配置源"><a class="header" href="#三种配置源">三种配置源</a></h4>
<p>关键过程位于<code>pkg/scheduler/scheduler.go</code></p>
<pre><code class="language-Go">func New(client clientset.Interface,
  informerFactory informers.SharedInformerFactory,
  recorderFactory profile.RecorderFactory,
  stopCh &lt;-chan struct{},
  opts ...Option) (*Scheduler, error)
</code></pre>
<p>根据配置的<code>schedulerAlgorithmSource</code>不同，有三个分支，第一种就是用默认的provider，第二种是读取文件配置，第三种是读取configmap配置</p>
<pre><code class="language-Go">  switch {
  case source.Provider != nil:
    // Create the config from a named algorithm provider.
    sc, err := configurator.createFromProvider(*source.Provider)
    if err != nil {
      return nil, fmt.Errorf("couldn't create scheduler using provider %q: %v", *source.Provider, err)
    }
    sched = sc
  case source.Policy != nil:
    // Create the config from a user specified policy source.
    policy := &amp;schedulerapi.Policy{}
    switch {
    case source.Policy.File != nil:
      if err := initPolicyFromFile(source.Policy.File.Path, policy); err != nil {
        return nil, err
      }
    case source.Policy.ConfigMap != nil:
      if err := initPolicyFromConfigMap(client, source.Policy.ConfigMap, policy); err != nil {
        return nil, err
      }
    }
  } 
</code></pre>
<h4 id="默认配置"><a class="header" href="#默认配置">默认配置</a></h4>
<p>我们就直接看默认配置吧。</p>
<p>位于<code>pkg/scheduler/factory.go</code>的<code>createFromProvider</code></p>
<pre><code class="language-Go">// createFromProvider creates a scheduler from the name of a registered algorithm provider.
func (c *Configurator) createFromProvider(providerName string) (*Scheduler, error) {
  klog.V(2).InfoS("Creating scheduler from algorithm provider", "algorithmProvider", providerName)
  r := algorithmprovider.NewRegistry()
  defaultPlugins, exist := r[providerName]
  if !exist {
    return nil, fmt.Errorf("algorithm provider %q is not registered", providerName)
  }

  for i := range c.profiles {
    prof := &amp;c.profiles[i]
    plugins := &amp;schedulerapi.Plugins{}
    plugins.Append(defaultPlugins)
    plugins.Apply(prof.Plugins)
    prof.Plugins = plugins
  }
  return c.create()
}
</code></pre>
<p>其中<code>profiles </code>是个<code>KubeSchedulerProfile</code>结构，其中有<code>SchedulerName</code>, <code>Plugins</code>， 如果没有指定<code>SchedulerName</code>默认等于<code>"default-scheduler"</code></p>
<pre><code class="language-Go">type KubeSchedulerProfile struct {
  // SchedulerName is the name of the scheduler associated to this profile.
  // If SchedulerName matches with the pod's "spec.schedulerName", then the pod
  // is scheduled with this profile.
  SchedulerName string

  // Plugins specify the set of plugins that should be enabled or disabled.
  // Enabled plugins are the ones that should be enabled in addition to the
  // default plugins. Disabled plugins are any of the default plugins that
  // should be disabled.
  // When no enabled or disabled plugin is specified for an extension point,
  // default plugins for that extension point will be used if there is any.
  // If a QueueSort plugin is specified, the same QueueSort Plugin and
  // PluginConfig must be specified for all profiles.
  Plugins *Plugins

  // PluginConfig is an optional set of custom plugin arguments for each plugin.
  // Omitting config args for a plugin is equivalent to using the default config
  // for that plugin.
  PluginConfig []PluginConfig
}

</code></pre>
<p>默认的<code>Plugins</code>配置位于<code>pkg/scheduler/algorithmprovider/registry.go</code>，这个配置相当长，具体有什么pulugin可以查看代码</p>
<pre><code class="language-Go">func getDefaultConfig() *schedulerapi.Plugins
</code></pre>
<h4 id="plugins是什么"><a class="header" href="#plugins是什么">Plugins是什么</a></h4>
<p>plugins就是为了给pod分配节点，而创建的各种算法插件。</p>
<p>默认配置中主要配置了各种plugins，plugins可以分为这么几类（详情可以查看<code>pkg/scheduler/apis/config/types.go</code>中的<code>Plugins</code>结构体）：</p>
<ol>
<li>
<p><strong>QueueSort</strong>: 给pod排序的</p>
</li>
<li>
<p><strong>PreFilter</strong>: 在filter之前执行一下</p>
</li>
<li>
<p><strong>Filter</strong>: 过滤不可用的节点,</p>
</li>
<li>
<p>**PostFilter：**过滤后执行一下</p>
</li>
<li>
<p>**PreScore ：**打分前执行一下</p>
</li>
<li>
<p><strong>Score</strong>：在给node排名时打分</p>
</li>
<li>
<p><strong>Reserve</strong>：在node被分配给一个pod后执行，用来保留或取消保留某些资源</p>
</li>
<li>
<p><strong>Permit</strong>：在执行bind node之前执行，用来组织或者延迟bind</p>
</li>
<li>
<p>**PreBind：**在执行bind node之前执行</p>
</li>
<li>
<p>**Bind：**执行bind（只有一个DefaultBinder实现了）</p>
</li>
<li>
<p><strong>PostBind</strong>：bind成功后执行</p>
</li>
</ol>
<p><code>Pulgin</code>的<code>interface</code>定义位于<code>pkg/scheduler/framework/interface.go</code>，有上述提到的各种Plugin的接口定义</p>
<h3 id="创建scheduler"><a class="header" href="#创建scheduler">创建Scheduler</a></h3>
<h4 id="生成schedulingqueue"><a class="header" href="#生成schedulingqueue">生成SchedulingQueue</a></h4>
<p>SchedulingQueue接收了lessFn（也就是排序函数），在SchedulingQueue中会实现pod的排序。后面的NextPod也是调用了SchedulingQueue的Pop方法</p>
<pre><code class="language-Go">  lessFn := profiles[c.profiles[0].SchedulerName].QueueSortFunc()
  podQueue := internalqueue.NewSchedulingQueue(
    lessFn,
    c.informerFactory,
    internalqueue.WithPodInitialBackoffDuration(time.Duration(c.podInitialBackoffSeconds)*time.Second),
    internalqueue.WithPodMaxBackoffDuration(time.Duration(c.podMaxBackoffSeconds)*time.Second),
    internalqueue.WithPodNominator(nominator),
    internalqueue.WithClusterEventMap(clusterEventMap),
  )
</code></pre>
<h4 id="framework接口"><a class="header" href="#framework接口">Framework接口</a></h4>
<p>从profiles生成profile map，关键代码位于<code>pkg/scheduler/factory.go</code></p>
<pre><code class="language-Go">// create a scheduler from a set of registered plugins.
func (c *Configurator) create() (*Scheduler, error) {
// ......
  profiles, err := profile.NewMap(c.profiles, c.registry, c.recorderFactory,
    frameworkruntime.WithClientSet(c.client),
    frameworkruntime.WithInformerFactory(c.informerFactory),
    frameworkruntime.WithSnapshotSharedLister(c.nodeInfoSnapshot),
    frameworkruntime.WithRunAllFilters(c.alwaysCheckAllPredicates),
    frameworkruntime.WithPodNominator(nominator),
    frameworkruntime.WithCaptureProfile(frameworkruntime.CaptureProfile(c.frameworkCapturer)),
    frameworkruntime.WithClusterEventMap(clusterEventMap),
    frameworkruntime.WithParallelism(int(c.parallellism)),
  )
// ......
  return &amp;Scheduler{
    SchedulerCache:  c.schedulerCache,
    Algorithm:       algo,
    Profiles:        profiles,
    NextPod:         internalqueue.MakeNextPodFunc(podQueue),
    Error:           MakeDefaultErrorFunc(c.client, c.informerFactory.Core().V1().Pods().Lister(), podQueue, c.schedulerCache),
    StopEverything:  c.StopEverything,
    SchedulingQueue: podQueue,
  }, nil
} 
</code></pre>
<p>其中profiles是个map （<code>type Map map[string]framework.Framework</code>），从<code>KubeSchedulerProfile</code>结构生成<code>framework.Framework</code>的关键代码位于<code>pkg/scheduler/profile/profile.go</code></p>
<pre><code class="language-Go">// newProfile builds a Profile for the given configuration.
func newProfile(cfg config.KubeSchedulerProfile, r frameworkruntime.Registry, recorderFact RecorderFactory,
  opts ...frameworkruntime.Option) (framework.Framework, error) {
  recorder := recorderFact(cfg.SchedulerName)
  opts = append(opts, frameworkruntime.WithEventRecorder(recorder))
  fwk, err := frameworkruntime.NewFramework(r, &amp;cfg, opts...)
  if err != nil {
    return nil, err
  }
  return fwk, nil
}
</code></pre>
<p>Framework接口的定义位于<code>pkg/scheduler/framework/interface.go</code></p>
<h4 id="生成plugins接口"><a class="header" href="#生成plugins接口">生成Plugins接口</a></h4>
<p>关键过程位于<code>pkg/scheduler/framework/runtime/framework.go</code></p>
<pre><code class="language-Go">// NewFramework initializes plugins given the configuration and the registry.
func NewFramework(r Registry, profile *config.KubeSchedulerProfile, opts ...Option) (framework.Framework, error)
</code></pre>
<p>其中的参数<code>Registry</code>是个PluginFactory map</p>
<pre><code class="language-Go">type Registry map[string]PluginFactory
</code></pre>
<p>根据Registry可以生成pluginsMap，</p>
<pre><code class="language-Go">pluginsMap := make(map[string]framework.Plugin)
</code></pre>
<p>通过反射，将plugin注入到framework中的各种plugins</p>
<pre><code class="language-Go">  for _, e := range f.getExtensionPoints(profile.Plugins) {
    if err := updatePluginList(e.slicePtr, e.plugins, pluginsMap); err != nil {
      return nil, err
    }
  }
</code></pre>
<p><code>getExtensionPoints</code>以及<code>updatePluginList</code>的定义：</p>
<pre><code class="language-Go">func (f *frameworkImpl) getExtensionPoints(plugins *config.Plugins) []extensionPoint {
  return []extensionPoint{
    {plugins.PreFilter, &amp;f.preFilterPlugins},
    {plugins.Filter, &amp;f.filterPlugins},
    {plugins.PostFilter, &amp;f.postFilterPlugins},
    {plugins.Reserve, &amp;f.reservePlugins},
    {plugins.PreScore, &amp;f.preScorePlugins},
    {plugins.Score, &amp;f.scorePlugins},
    {plugins.PreBind, &amp;f.preBindPlugins},
    {plugins.Bind, &amp;f.bindPlugins},
    {plugins.PostBind, &amp;f.postBindPlugins},
    {plugins.Permit, &amp;f.permitPlugins},
    {plugins.QueueSort, &amp;f.queueSortPlugins},
  }
}

func updatePluginList(pluginList interface{}, pluginSet config.PluginSet, pluginsMap map[string]framework.Plugin) error {
  plugins := reflect.ValueOf(pluginList).Elem()
  pluginType := plugins.Type().Elem()
  set := sets.NewString()
  for _, ep := range pluginSet.Enabled {
    pg, ok := pluginsMap[ep.Name]
    if !ok {
      return fmt.Errorf("%s %q does not exist", pluginType.Name(), ep.Name)
    }

    if !reflect.TypeOf(pg).Implements(pluginType) {
      return fmt.Errorf("plugin %q does not extend %s plugin", ep.Name, pluginType.Name())
    }

    if set.Has(ep.Name) {
      return fmt.Errorf("plugin %q already registered as %q", ep.Name, pluginType.Name())
    }

    set.Insert(ep.Name)

    newPlugins := reflect.Append(plugins, reflect.ValueOf(pg))
    plugins.Set(newPlugins)
  }
  return nil
}
</code></pre>
<p>这样子Framework就拥有了各种plugins</p>
<h3 id="scheduler执行过程"><a class="header" href="#scheduler执行过程">Scheduler执行过程</a></h3>
<p>主函数就是<code>scheduleOne</code>这个方法。其余过程就不看了，主要看下那些plugins是怎么执行的。</p>
<h4 id="创建了cyclestate"><a class="header" href="#创建了cyclestate">创建了CycleState</a></h4>
<pre><code class="language-Go">state := framework.NewCycleState()
</code></pre>
<p>这个<code>CycleState</code>位于<code>pkg/scheduler/framework/cycle_state.go</code>，它主要记录一些key值</p>
<pre><code class="language-Go">type CycleState struct {
  mx      sync.RWMutex
  storage map[StateKey]StateData
  // if recordPluginMetrics is true, PluginExecutionDuration will be recorded for this cycle.
  recordPluginMetrics bool
}
</code></pre>
<h4 id="执行调度过程"><a class="header" href="#执行调度过程">执行调度过程</a></h4>
<pre><code class="language-Go">scheduleResult, err := sched.Algorithm.Schedule(schedulingCycleCtx, fwk, state, pod)
</code></pre>
<p><code>Algorithm</code>实际实现的地方位于<code>pkg/scheduler/core/generic_scheduler.go</code>中的这个结构体<code>genericScheduler</code></p>
<p>首先进行 snapshot，获取集群信息</p>
<pre><code class="language-Go">  if err := g.snapshot(); err != nil {
    return result, err
  }
</code></pre>
<h5 id="获取合适的节点"><a class="header" href="#获取合适的节点">获取合适的节点</a></h5>
<pre><code class="language-Go">feasibleNodes, diagnosis, err := g.findNodesThatFitPod(ctx, fwk, state, pod)
</code></pre>
<h6 id="prefilter"><a class="header" href="#prefilter">PreFilter</a></h6>
<pre><code class="language-Go">s := fwk.RunPreFilterPlugins(ctx, state, pod)
</code></pre>
<h6 id="filter"><a class="header" href="#filter">Filter</a></h6>
<p>用plugin进行Filter</p>
<pre><code class="language-Go">status := fwk.RunFilterPluginsWithNominatedPods(ctx, state, pod, nodeInfo)
</code></pre>
<p>用extender进行Filter</p>
<pre><code class="language-Go">feasibleNodes, err = g.findNodesThatPassExtenders(pod, feasibleNodes, diagnosis.NodeToStatusMap)
</code></pre>
<h5 id="优先节点"><a class="header" href="#优先节点">优先节点</a></h5>
<h6 id="prescore"><a class="header" href="#prescore">PreScore</a></h6>
<pre><code class="language-Go">preScoreStatus := fwk.RunPreScorePlugins(ctx, state, pod, nodes)
</code></pre>
<h6 id="score"><a class="header" href="#score">Score</a></h6>
<pre><code class="language-Go">scoresMap, scoreStatus := fwk.RunScorePlugins(ctx, state, pod, nodes)
</code></pre>
<h5 id="选择节点"><a class="header" href="#选择节点">选择节点</a></h5>
<p>选择最高分的节点</p>
<pre><code class="language-Go">host, err := g.selectHost(priorityList)
</code></pre>
<h5 id="bind之前"><a class="header" href="#bind之前">Bind之前</a></h5>
<h6 id="assume"><a class="header" href="#assume">Assume</a></h6>
<pre><code class="language-Go">err = sched.assume(assumedPod, scheduleResult.SuggestedHost)
</code></pre>
<h6 id="reserve"><a class="header" href="#reserve">Reserve</a></h6>
<pre><code class="language-Go">sts := fwk.RunReservePluginsReserve(schedulingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost);
</code></pre>
<h6 id="permit"><a class="header" href="#permit">Permit</a></h6>
<pre><code class="language-Go">runPermitStatus := fwk.RunPermitPlugins(schedulingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)
</code></pre>
<h6 id="unreserve"><a class="header" href="#unreserve">Unreserve</a></h6>
<pre><code class="language-Go">fwk.RunReservePluginsUnreserve(schedulingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)
</code></pre>
<h5 id="异步执行bind"><a class="header" href="#异步执行bind">异步执行Bind</a></h5>
<h6 id="prebind"><a class="header" href="#prebind">PreBind</a></h6>
<pre><code class="language-Go">preBindStatus := fwk.RunPreBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)
</code></pre>
<h6 id="bind"><a class="header" href="#bind">Bind</a></h6>
<pre><code class="language-Go">go func() {
  // ......
  err := sched.bind(bindingCycleCtx, fwk, assumedPod, scheduleResult.SuggestedHost, state)
  // ......
} 
</code></pre>
<h6 id="postbind"><a class="header" href="#postbind">PostBind</a></h6>
<pre><code class="language-Go">fwk.RunPostBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="client-go-list--watch-原理"><a class="header" href="#client-go-list--watch-原理">client-go list &amp; watch 原理</a></h1>
<p>ListAndWatch设计到两个操作</p>
<p>List和Watch</p>
<p>List没啥好说的</p>
<p>看看Watch：</p>
<h1 id="watch原理"><a class="header" href="#watch原理">Watch原理</a></h1>
<h2 id="概要"><a class="header" href="#概要">概要</a></h2>
<p>kube-apiserver与etcd之间有个长连接（GRPC stream），对资源进行watch</p>
<p>kube-apiserver与client-go之间有个长连接（websocket或Transfer-Encoding），作为etcd watch的代理</p>
<h2 id="api-server"><a class="header" href="#api-server">API Server</a></h2>
<h3 id="watch接口"><a class="header" href="#watch接口">Watch接口</a></h3>
<p>在<code>staging/src/k8s.io/apiserver/pkg/endpoints/handlers/get.go</code>中，有个<code>ListResource</code>接口，其中实现了对资源的watch接口</p>
<pre><code class="language-Go">if opts.Watch || forceWatch {
  // 省略
  // ......
  metrics.RecordLongRunning(req, requestInfo, metrics.APIServerComponent, func() {
    serveWatch(watcher, scope, outputMediaType, req, w, timeout)
  })
  return
} 
// 省略 
</code></pre>
<p>我们继续往下看<code>serveWatch</code>中发生了什么</p>
<p>在<code>pkg/endpoints/handlers/watch.go</code>中有：</p>
<pre><code class="language-Go">server := &amp;WatchServer{
    Watching: watcher,
    Scope:    scope,

    UseTextFraming:  useTextFraming,
    MediaType:       mediaType,
    Framer:          framer,
    Encoder:         encoder,
    EmbeddedEncoder: embeddedEncoder,

    Fixup: func(obj runtime.Object) runtime.Object {
      result, err := transformObject(ctx, obj, options, mediaTypeOptions, scope, req)
      if err != nil {
        utilruntime.HandleError(fmt.Errorf("failed to transform object %v: %v", reflect.TypeOf(obj), err))
        return obj
      }
      // When we are transformed to a table, use the table options as the state for whether we
      // should print headers - on watch, we only want to print table headers on the first object
      // and omit them on subsequent events.
      if tableOptions, ok := options.(*metav1.TableOptions); ok {
        tableOptions.NoHeaders = true
      }
      return result
    },

    TimeoutFactory: &amp;realTimeoutFactory{timeout},
  }

  server.ServeHTTP(w, req)
</code></pre>
<p>可见WatcheServer是实现watch接口的关键组件，在<code>ServeHTTP</code>方法中，出现了两个分支</p>
<pre><code class="language-Go">if wsstream.IsWebSocketRequest(req) {
    w.Header().Set("Content-Type", s.MediaType)
    websocket.Handler(s.HandleWS).ServeHTTP(w, req)
    return
  }
// ......省略
 // begin the stream
  w.Header().Set("Content-Type", s.MediaType)
  w.Header().Set("Transfer-Encoding", "chunked")
  w.WriteHeader(http.StatusOK)
  flusher.Flush()
  // ......省略 
</code></pre>
<p>可见如果WatchServer同时实现了<code>websocket</code>接口以及http的<code>Transfer-Encoding</code>接口（分块传输编码，http长连接，单向的？）。</p>
<p>而在传输数据的部分：</p>
<pre><code class="language-Go">  ch := s.Watching.ResultChan()
  done := req.Context().Done()

  for {
    select {
    case &lt;-done:
      return
    case &lt;-timeoutCh:
      return
    case event, ok := &lt;-ch:
      if !ok {
        // End of results.
        return
      }
// ......省略 
</code></pre>
<p>这里<code>s.Watching</code>就是对etcd的资源watch的接口，<code>s.Watching.ResultChan</code>是资源watch event。</p>
<p><code>s.Watching</code>其实是一个<code>watch.Interface</code>对象，它是从哪里来的</p>
<h3 id="watcher对象"><a class="header" href="#watcher对象">Watcher对象</a></h3>
<p>一路追查</p>
<p>位于<code>staging/src/k8s.io/apiserver/pkg/storage/etcd3/store.go</code>中的<code>Watch</code>以及<code>WatchList</code>接口创建了<code>watch.Interface</code>对象</p>
<pre><code class="language-Go">// Watch implements storage.Interface.Watch.
func (s *store) Watch(ctx context.Context, key string, opts storage.ListOptions) (watch.Interface, error) {
  return s.watch(ctx, key, opts, false)
}

// WatchList implements storage.Interface.WatchList.
func (s *store) WatchList(ctx context.Context, key string, opts storage.ListOptions) (watch.Interface, error) {
  return s.watch(ctx, key, opts, true)
}

func (s *store) watch(ctx context.Context, key string, opts storage.ListOptions, recursive bool) (watch.Interface, error) {
  rev, err := s.versioner.ParseResourceVersion(opts.ResourceVersion)
  if err != nil {
    return nil, err
  }
  key = path.Join(s.pathPrefix, key)
  return s.watcher.Watch(ctx, key, int64(rev), recursive, opts.ProgressNotify, opts.Predicate)
}
</code></pre>
<p>位于<code>staging/src/k8s.io/apiserver/pkg/storage/etcd3/watcher.go</code>的<code>startWatching</code>函数，调用了etcd client的<code>watch</code>接口，关键代码：</p>
<pre><code class="language-Go">
// startWatching does:
// - get current objects if initialRev=0; set initialRev to current rev
// - watch on given key and send events to process.
func (wc *watchChan) startWatching(watchClosedCh chan struct{}) {
  // 省略......
  wch := wc.watcher.client.Watch(wc.ctx, wc.key, opts...)
  // 省略......
}
</code></pre>
<h2 id="client-go"><a class="header" href="#client-go">Client-Go</a></h2>
<h3 id="创建sharedinformerfactory"><a class="header" href="#创建sharedinformerfactory">创建<code>SharedInformerFactory</code></a></h3>
<pre><code class="language-Go">func NewFilteredSharedInformerFactory(client kubernetes.Interface, defaultResync time.Duration, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerFactory {
  return NewSharedInformerFactoryWithOptions(client, defaultResync, WithNamespace(namespace), WithTweakListOptions(tweakListOptions))
}
</code></pre>
<h3 id="创建podinformer"><a class="header" href="#创建podinformer">创建PodInformer</a></h3>
<p>创建了SharedIndexInformer接口</p>
<p>ListWatch结构保存了ListFunc和WatchFunc</p>
<pre><code class="language-Go">func NewFilteredPodInformer(client kubernetes.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer {
  return cache.NewSharedIndexInformer(
    &amp;cache.ListWatch{
      ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
        if tweakListOptions != nil {
          tweakListOptions(&amp;options)
        }
        return client.CoreV1().Pods(namespace).List(context.TODO(), options)
      },
      WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
        if tweakListOptions != nil {
          tweakListOptions(&amp;options)
        }
        return client.CoreV1().Pods(namespace).Watch(context.TODO(), options)
      },
    },
    &amp;corev1.Pod{},
    resyncPeriod,
    indexers,
  )
}
</code></pre>
<h3 id="sharedindexinformer"><a class="header" href="#sharedindexinformer">SharedIndexInformer</a></h3>
<p>SharedIndexInformer接口定义了诸如AddEventHandler、Run、HasSynced等方法</p>
<p>结构体的一些关键成员：</p>
<ul>
<li>
<p><strong>processor</strong>：实现了对object的watch</p>
</li>
<li>
<p><strong>indexer</strong>：一个本地缓存，保存list &amp; watch得到的结构体，当object被删掉时，本地缓存也会删掉</p>
</li>
<li>
<p><strong>listerWatcher</strong>：制定了对哪个对象类型进行list &amp; watch</p>
</li>
</ul>
<pre><code class="language-Go">func NewSharedIndexInformer(lw ListerWatcher, exampleObject runtime.Object, defaultEventHandlerResyncPeriod time.Duration, indexers Indexers) SharedIndexInformer {
  realClock := &amp;clock.RealClock{}
  sharedIndexInformer := &amp;sharedIndexInformer{
    processor:                       &amp;sharedProcessor{clock: realClock},
    indexer:                         NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers),
    listerWatcher:                   lw,
    objectType:                      exampleObject,
    resyncCheckPeriod:               defaultEventHandlerResyncPeriod,
    defaultEventHandlerResyncPeriod: defaultEventHandlerResyncPeriod,
    cacheMutationDetector:           NewCacheMutationDetector(fmt.Sprintf("%T", exampleObject)),
    clock:                           realClock,
  }
  return sharedIndexInformer
}
</code></pre>
<h3 id="sharedindexinformerrun过程"><a class="header" href="#sharedindexinformerrun过程">SharedIndexInformer::Run过程</a></h3>
<ol>
<li>
<p>创建一个Controller（包含了FINO Queue，ListWatcher），将SharedIndexInformer的HandleDeltas方法注入给Controller的Process</p>
</li>
<li>
<p>Controller Run， processor Run</p>
</li>
</ol>
<h3 id="controller"><a class="header" href="#controller">Controller</a></h3>
<p>Controller其实就是负责对资源的list &amp; watch，每当获取到一个object就调用一下Process</p>
<p>Controller中的几个重要成员</p>
<ol>
<li>
<p><strong>FIFO Queue</strong>：Controller会对Queue进行轮询，当有新的object pop出来时，就调用Process方法。</p>
</li>
<li>
<p><strong>Reflector</strong>：真正调用ListWatcher的地方，Reflector有个Store成员，其实就是Controller的<code>FIFO Queue</code>。在<code>Reflector::Run</code>房中法中，首先进行List把所有object保存到store中，然后调用ListWatcher的watch方法，当收到event时，就对store进行update.这里应该就是所谓的<strong>二级缓存</strong>，watch得到的event先保存在一个ratelimit queue中，然后再对store进行更新。</p>
</li>
</ol>
<h3 id="sharedprocessor"><a class="header" href="#sharedprocessor">sharedProcessor</a></h3>
<p>sharedProcessor添加了一个processorListener结构，processorListener包含了HandlerFunc</p>
<p>具体嗲用handlerFunc的过程：</p>
<ol>
<li>
<p>在Informer的HandleDeltas方法中，调用了sharedProcessor的distribute方法对每个object进行处理</p>
</li>
<li>
<p>在distribute方法中调用了listener的add方法, add 方法中将object传给一个channel</p>
</li>
<li>
<p>在add方法中，会传给nextCh成员</p>
</li>
<li>
<p>在run方法中，接受nextCh，并调用handler</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="what-is-kubernetes-service"><a class="header" href="#what-is-kubernetes-service">What is Kubernetes Service</a></h1>
<p>将运行在一组 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pods</a> 上的应用程序公开为网络服务的抽象方法。</p>
<p>使用 Kubernetes，你无需修改应用程序即可使用不熟悉的服务发现机制。 Kubernetes 为 Pods 提供自己的 IP 地址，并为一组 Pod 提供相同的 DNS 名， 并且可以在它们之间进行负载均衡。</p>
<p>在</p>
<h1 id="why-use-service"><a class="header" href="#why-use-service">Why Use Service</a></h1>
<h1 id="how-service-works"><a class="header" href="#how-service-works">How Service Works</a></h1>
<h2 id="创建了一个service之后会发生什么"><a class="header" href="#创建了一个service之后会发生什么">创建了一个Service之后会发生什么</a></h2>
<ol>
<li>客户端访问kube-apiserver，创建一个service资源，apiserver将service保存在etcd</li>
<li>service controller watch到这个被创建的service，</li>
</ol>
<h3 id="service-controller"><a class="header" href="#service-controller">Service Controller</a></h3>
<h3 id="endpoints-controller原理todo"><a class="header" href="#endpoints-controller原理todo">Endpoints Controller原理（TODO）</a></h3>
<h4 id="pod-挂了一个sidecar时kube-dns还会生效吗"><a class="header" href="#pod-挂了一个sidecar时kube-dns还会生效吗">pod 挂了一个sidecar时，kube dns还会生效吗</a></h4>
<p>pod 的 status.conditions字段，里面如果是conditon是not ready的，service对应的endpoints只会把pod ip更新到 NotReadyAddress 字段
然而1.14版的kube-dns只会根据endpoints的 Address 字段注册域名ip</p>
<p>endpoints_controller.go中的endpoint更新逻辑：</p>
<pre><code class="language-go">func addEndpointSubset(subsets []v1.EndpointSubset, pod *v1.Pod, epa v1.EndpointAddress,
	epp *v1.EndpointPort, tolerateUnreadyEndpoints bool) ([]v1.EndpointSubset, int, int) {
	var readyEps int = 0
	var notReadyEps int = 0
	ports := []v1.EndpointPort{}
	if epp != nil {
		ports = append(ports, *epp)
	}
	if tolerateUnreadyEndpoints || podutil.IsPodReady(pod) {
		subsets = append(subsets, v1.EndpointSubset{
			Addresses: []v1.EndpointAddress{epa},
			Ports:     ports,
		})
		readyEps++
	} else if shouldPodBeInEndpoints(pod) {
		glog.V(5).Infof("Pod is out of service: %s/%s", pod.Namespace, pod.Name)
		subsets = append(subsets, v1.EndpointSubset{
			NotReadyAddresses: []v1.EndpointAddress{epa},
			Ports:             ports,
		})
		notReadyEps++
	}
	return subsets, readyEps, notReadyEps
}
</code></pre>
<p>kube-dns 中的注册ip的逻辑：</p>
<pre><code class="language-go">func (kd *KubeDNS) generateRecordsForHeadlessService(e *v1.Endpoints, svc *v1.Service) error {
	subCache := treecache.NewTreeCache()
	glog.V(4).Infof("Endpoints Annotations: %v", e.Annotations)
	for idx := range e.Subsets {
		for subIdx := range e.Subsets[idx].Addresses {
			address := &amp;e.Subsets[idx].Addresses[subIdx]
			endpointIP := address.IP
			recordValue, endpointName := util.GetSkyMsg(endpointIP, 0)
			if hostLabel, exists := getHostname(address); exists {
				endpointName = hostLabel
			}
			subCache.SetEntry(endpointName, recordValue, kd.fqdn(svc, endpointName))
			for portIdx := range e.Subsets[idx].Ports {
				endpointPort := &amp;e.Subsets[idx].Ports[portIdx]
				if endpointPort.Name != "" &amp;&amp; endpointPort.Protocol != "" {
					srvValue := kd.generateSRVRecordValue(svc, int(endpointPort.Port), endpointName)
					glog.V(2).Infof("Added SRV record %+v", srvValue)

					l := []string{"_" + strings.ToLower(string(endpointPort.Protocol)), "_" + endpointPort.Name}
					subCache.SetEntry(endpointName, srvValue, kd.fqdn(svc, append(l, endpointName)...), l...)
				}
			}

			// Generate PTR records only for Named Headless service.
			if _, has := getHostname(address); has {
				reverseRecord, _ := util.GetSkyMsg(kd.fqdn(svc, endpointName), 0)
				kd.reverseRecordMap[endpointIP] = reverseRecord
			}
		}
	}
	subCachePath := append(kd.domainPath, serviceSubdomain, svc.Namespace)
	kd.cacheLock.Lock()
	defer kd.cacheLock.Unlock()
	kd.cache.SetSubCache(svc.Name, subCache, subCachePath...)
	return nil
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cni详解-1"><a href="#cni详解-1" class="header">cni详解</a></h1>
<h2 id="cni-的作用"><a class="header" href="#cni-的作用">CNI 的作用:</a></h2>
<p>参考: <a href="https://hansedong.github.io/2019/03/19/14/">K8S CNI之：利用ipvlan+host-local+ptp打通容器与宿主机的平行网络 | 国南之境 (hansedong.github.io)</a></p>
<ul>
<li>
<p>给Pod分配IP</p>
</li>
<li>
<p>创建 network namespace, veth pair 以及 bridge</p>
<ul>
<li>veth 一端放进容器的 net namespace</li>
<li>另一端放在 host</li>
<li>host网卡以及 veth 设备加入 bridge , 这样容器才能与 host 通信</li>
</ul>
</li>
<li>
<p>设置 route 规则</p>
<ul>
<li>指向本节点的 pod ip, gateway 设置成当前节点( iface 为对应的 veth)</li>
</ul>
</li>
</ul>
<p>另外如果要跨节点通信,</p>
<ul>
<li>在节点上手动设置 route 规则 (<code>ip route add</code>)
<ul>
<li>指向其他节点上的 Pod CIDR, gateway 设置成对应的节点 IP, 或者设置成交换机的 IP</li>
</ul>
</li>
</ul>
<p>查看network namespace</p>
<pre><code class="language-bash"># ip netns list
cni-26105ccb-b905-e5b7-09e2-159a9f58ab64 (id: 1)
</code></pre>
<p>查看 veth</p>
<pre><code class="language-bash"># ip link show type veth
4: vethbdd29507@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default 
    link/ether 06:a5:48:56:05:94 brd ff:ff:ff:ff:ff:ff link-netns cni-0d153976-a5a0-b8b8-9bb8-2d6938f2ed3d
31: eth0@if32: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default 
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
</code></pre>
<p>查看 路由规则</p>
<pre><code class="language-bash"># ip route
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.18.0.1      0.0.0.0         UG    0      0        0 eth0
10.244.0.0      172.18.0.4      255.255.255.0   UG    0      0        0 eth0
10.244.1.2      0.0.0.0         255.255.255.255 UH    0      0        0 vethbdd29507
10.244.2.0      172.18.0.3      255.255.255.0   UG    0      0        0 eth0
172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0
# 或者
# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.18.0.1      0.0.0.0         UG    0      0        0 eth0
10.244.0.0      172.18.0.4      255.255.255.0   UG    0      0        0 eth0
10.244.1.2      0.0.0.0         255.255.255.255 UH    0      0        0 vethbdd29507
10.244.2.0      172.18.0.3      255.255.255.0   UG    0      0        0 eth0
172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0
</code></pre>
<h2 id="kind-是怎么做的"><a class="header" href="#kind-是怎么做的">Kind 是怎么做的?</a></h2>
<p>每个节点部署了一个 kindnetd</p>
<pre><code class="language-bash"># kubectl -n kube-system  get ds kindnet
NAME      DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE
kindnet   3         3         3       3            3           &lt;none&gt;          4h57m
</code></pre>
<p>kindnet 的作用:</p>
<ul>
<li>
<p>动态配置每个节点的 cni 里的 CIDR</p>
</li>
<li>
<p>自动配置节点上的 route 规则, 这样才能跨节点通信</p>
</li>
<li>
<p>自动配置iptabels 规则, 给所有目标是<strong>集群之外</strong>的流量, 做 MASQUERADE (即把源 IP 自动改成当前的IP)</p>
<blockquote>
<p>为什么要改掉源 IP ? 假设这样的场景, 内网机器要访问外网, 外网服务器接受到请求后, 返回响应时要给哪个IP发送呢? 直接发给内网IP是无法访问的, 所以需要做 SNAT, 源IP设置成外网可见的网关(Gateway)</p>
</blockquote>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="flowschema-1"><a href="#flowschema-1" class="header">flowschema</a></h1>
<h2 id="what-is-flowschema"><a class="header" href="#what-is-flowschema">What is FlowSchema</a></h2>
<p>FlowSchema一种 resoruce, 它可以配置 kube-apiserver 的流量控制. 比如对于哪种流量需要优先处理, 哪种流量可以拒绝, 哪种流量如果来不及处理就先加到队列中.</p>
<p>A flowschema spec is like this:</p>
<pre><code class="language-yaml">apiVersion: flowcontrol.apiserver.k8s.io/v1beta1
kind: FlowSchema
metadata:
 name: fcp-service
spec:
 distinguisherMethod:
   type: ByNamespace
 matchingPrecedence: 50
 priorityLevelConfiguration:
   name: system
 rules:
 - nonResourceRules:
   - nonResourceURLs:
     - '*'
     verbs:
     - '*'
   resourceRules:
   - apiGroups:
     - '*'
     clusterScope: true
     namespaces:
     - '*'
     resources:
     - '*'
     verbs:
     - '*'
   subjects:
   - kind: ServiceAccount
     serviceAccount:
       name: '*'
       namespace: fcp-pp
</code></pre>
<h2 id="how-does-flowschema-work"><a class="header" href="#how-does-flowschema-work">How does FlowSchema work?</a></h2>
<p>FlowSchema 定义了一组 rules, 如果一个 request hit 其中一个 rule, 就可以认为它属于这个 FlowSchema.</p>
<p>然后这个flowschema对应的流量控制规则定义在 <code>priorityLevelConfiguration</code></p>
<p>PriorityLevelConfiguration 是另一种 resource, 它长这个样子:</p>
<pre><code class="language-yaml">kind: PriorityLevelConfiguration
metadata:
  name: system
spec:
  limited:
    assuredConcurrencyShares: 8000
    limitResponse:
      queuing:
        handSize: 15
        queueLengthLimit: 100
        queues: 15
      type: Queue
  type: Limited
status: {}
</code></pre>
<p>这个规则对应的并发限制和这个值 <code>assuredConcurrencyShares</code> 有关:</p>
<p>并发限制 = 总并发量 * assuredConcurrencyShares / 所有的assuredConcurrencyShares之和</p>
<blockquote>
<p>其中 总并发量 = max-requests-inflight + max-mutating-requests-inflight</p>
<p>max-requests-inflight 和 max-mutating-requests-inflight 是 kube-apiserver 参数</p>
</blockquote>
<p>举个例子:</p>
<p>apiserver 的 max-requests-inflight=4000 max-mutating-requests-inflight=2000</p>
<pre><code>bingtlu@R0016P43QH ~ % k get priorityLevelConfiguration
NAME              TYPE      ASSUREDCONCURRENCYSHARES   QUEUES   HANDSIZE   QUEUELENGTHLIMIT   AGE
catch-all         Limited   1                          &lt;none&gt;   &lt;none&gt;     &lt;none&gt;             679d
exempt            Exempt    &lt;none&gt;                     &lt;none&gt;   &lt;none&gt;     &lt;none&gt;             679d
federation        Limited   4000                       128      6          50                 679d
global-default    Limited   2000                       128      6          50                 679d
leader-election   Limited   1000                       16       4          50                 679d
system            Limited   8000                       15       15         100                679d
workload-high     Limited   3000                       128      6          50                 679d
workload-low      Limited   2500                       128      6          50                 679d
</code></pre>
<p>system的并发限制 = 6000 * 8000 / (1+4000+2000+1000+8000+3000+2500) = 2341.35</p>
<p>如果超出了这个并发量怎么办? 加到队列里面等待. 一个 priorityLevelConfiguration 包含多个queue, 根据 <code>distinguisherMethod</code>分流(flows), 不同的 flow 不会冲突 (比如distinguisherMethod 是 ByUser, 那么当某个user发了大量请求, 不会阻塞另一个user的请求)</p>
<p>还有一种特殊的 priorityLevelConfiguration, 就是 <code>exempt</code>, exempt 就是没有限制, 一般会把最重要的request设置成 exempt, 比如group=system:masters</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="k8s之pleg-1"><a href="#k8s之pleg-1" class="header">k8s之pleg</a></h1>
<p>发现, 有僵尸进程时节点状态是 NodeNotReady, 同时 kubelet 日志显示:</p>
<pre><code>PLEG is not healthy: pleg was last seen active
</code></pre>
<p>清除掉僵尸进程后, 节点状态恢复</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="kubelet-原理"><a class="header" href="#kubelet-原理">Kubelet 原理</a></h1>
<h2 id="创建pod过程"><a class="header" href="#创建pod过程">创建Pod过程</a></h2>
<h3 id="1-syncloop循环监听管道信息"><a class="header" href="#1-syncloop循环监听管道信息">1. syncLoop循环监听管道信息</a></h3>
<p>监听多个 channel （file，http，apiserver，pleg），当发现任何一个 channel 有数据就交给 handler 去处理，在 handler 中通过调用 dispatchWork 分发任务</p>
<p>syncLoopIteration 根据pod 的不同事件，执行不同的逻辑</p>
<h3 id="2-handlepodadditions处理pod"><a class="header" href="#2-handlepodadditions处理pod">2. HandlePodAdditions处理pod</a></h3>
<p>HandlePodAdditions主要任务是：</p>
<ol>
<li>按照创建时间给pods进行排序；</li>
<li>将pod添加到pod管理器中，如果有pod不存在在pod管理器中，那么这个pod表示已经被删除了；</li>
<li>校验pod 是否能在该节点运行，如果不可以直接拒绝；</li>
<li>调用dispatchWork把 pod 分配给给 worker 做异步处理,创建pod；</li>
<li>将pod添加到probeManager中，如果 pod 中定义了 readiness 和 liveness 健康检查，启动 goroutine 定期进行检测；</li>
</ol>
<h3 id="3-dispatchwork"><a class="header" href="#3-dispatchwork">3. dispatchWork</a></h3>
<p>dispatchWork会封装一个UpdatePodOptions结构体丢给podWorkers.UpdatePod去执行</p>
<h3 id="4-updatepod"><a class="header" href="#4-updatepod">4. UpdatePod</a></h3>
<p>这个方法会加锁之后获取podUpdates数组里面数据，如果不存在那么会创建一个channel然后执行一个异步协程。</p>
<h3 id="5-managepodloop"><a class="header" href="#5-managepodloop">5. managePodLoop</a></h3>
<p>这个方法会遍历channel里面的数据，然后调用syncPodFn方法并传入一个syncPodOptions，kubelet会在执行NewMainKubelet方法的时候调用newPodWorkers方法设置syncPodFn为Kubelet的syncPod方法。</p>
<h3 id="6-syncpod"><a class="header" href="#6-syncpod">6. syncPod</a></h3>
<p>该方法主要是为创建pod前做一些准备工作。主要准备工作如下：</p>
<ol>
<li>校验该pod能否运行，如果不能运行，那么回写container的等待原因，然后更新状态管理器中的状态；</li>
<li>如果校验没通过或pod已被删除或pod跑失败了，那么kill掉pod，然后返回；</li>
<li>校验网络插件是否已准备好，如果没有，直接返回；</li>
<li>如果该pod的cgroups不存在，那么就创建cgroups（cgroup paraent后面会作为参数传给 createPodSandbox）；</li>
<li>为静态pod创建镜像；</li>
<li>创建pod的文件目录，等待volumes attach/mount；</li>
<li>拉取这个pod的Secret；</li>
<li>调用containerRuntime.SyncPod真正创建pod；</li>
</ol>
<h3 id="7-containerruntimesyncpod"><a class="header" href="#7-containerruntimesyncpod">7. containerRuntime.SyncPod</a></h3>
<ol>
<li>首先会调用computePodActions计算一下有哪些pod中container有没有变化，有哪些container需要创建,有哪些container需要kill掉；</li>
<li>kill掉 sandbox 已经改变的 pod；</li>
<li>如果有container已改变，那么需要调用killContainer方法kill掉ContainersToKill列表中的container；</li>
<li>调用pruneInitContainersBeforeStart方法清理同名的 Init Container；</li>
<li>调用createPodSandbox方法，创建需要被创建的Sandbox，关于Sandbox我们再下面说到；</li>
<li>如果开启了临时容器Ephemeral Container，那么需要创建相应的临时容器，临时容器可以看这篇：https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/；</li>
<li>获取NextInitContainerToStart中的container，调用startContainer启动init container；</li>
<li>获取ContainersToStart列表中的container，调用startContainer启动containers列表；</li>
</ol>
<h3 id="8-computepodactions"><a class="header" href="#8-computepodactions">8. computePodActions</a></h3>
<p>computePodActions方法主要做这么几件事：</p>
<ol>
<li>检查PodSandbox有没有改变，如果改变了，那么需要创建PodSandbox；</li>
<li>找到需要运行的Init Container设置到NextInitContainerToStart字段中；</li>
<li>找到需要被kill掉的Container列表ContainersToKill；</li>
<li>找到需要被启动的Container列表ContainersToStart；</li>
</ol>
<h3 id="9-sandbox"><a class="header" href="#9-sandbox">9. Sandbox</a></h3>
<p>Sandbox沙箱是一种程序的隔离运行机制，其目的是限制不可信进程的权限。k8s 中每个 pod 共享一个 sandbox定义了其 cgroup 及各种 namespace，所以同一个 pod 的所有容器才能够互通，且与外界隔离。我们在调用createPodSandbox方法创建sandbox的时候分为如下几步：</p>
<p><img src="docs/Cloud_Native/Kubernetes/kubelet原理.assets/20200926201151.png" alt="image-20200926163420747"></p>
<h3 id="10-startcontainer"><a class="header" href="#10-startcontainer">10. startContainer</a></h3>
<ol>
<li>拉取镜像；</li>
<li>计算一下Container重启次数，如果是首次创建，那么应该是0；</li>
<li>生成Container config，用于创建container；</li>
<li>调用CRI接口CreateContainer创建Container；</li>
<li>在启动之前调用PreStartContainer做预处理工作；</li>
<li>调用CRI接口StartContainer启动container；</li>
<li>调用生命周期中设置的钩子 post start；</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="kubernetes_ha-1"><a href="#kubernetes_ha-1" class="header">kubernetes_ha</a></h1>
<p>https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/ha-topology/#external-etcd-topology</p>
<h2 id="stacked-etcd-topology"><a class="header" href="#stacked-etcd-topology">Stacked etcd topology</a></h2>
<p>This topology couples the control planes and etcd members on the same nodes. It is simpler to set up than a cluster with external etcd nodes, and simpler to manage for replication.</p>
<p>However, a stacked cluster runs the risk of failed coupling. If one node goes down, both an etcd member and a control plane instance are lost, and redundancy is compromised. You can mitigate this risk by adding more control plane nodes.</p>
<p><img src="docs/Cloud_Native/Kubernetes/kubernetes_ha.assets/kubeadm-ha-topology-stacked-etcd.svg" alt="Stacked etcd topology"></p>
<h2 id="external-etcd-topology"><a class="header" href="#external-etcd-topology">External etcd topology</a></h2>
<p>This topology decouples the control plane and etcd member. It therefore provides an HA setup where losing a control plane instance or an etcd member has less impact and does not affect the cluster redundancy as much as the stacked HA topology.</p>
<p>However, this topology requires twice the number of hosts as the stacked HA topology. A minimum of three hosts for control plane nodes and three hosts for etcd nodes are required for an HA cluster with this topology.</p>
<p><img src="docs/Cloud_Native/Kubernetes/kubernetes_ha.assets/kubeadm-ha-topology-external-etcd.svg" alt="External etcd topology"></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rbac-1"><a href="#rbac-1" class="header">rbac</a></h1>
<h2 id="创建用户"><a class="header" href="#创建用户">创建用户</a></h2>
<p><a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/#normal-user">证书签名请求 | Kubernetes</a></p>
<p>假设用户名为 <code>devopstales</code>, 生成 private key (<code>.pem</code>文件), 生成证书请求 (<code>.csr</code>文件)</p>
<blockquote>
<p>O=组织信息，CN=用户名</p>
</blockquote>
<pre><code class="language-bash">openssl genrsa -out devopstales.pem
openssl req -new -key devopstales.pem -out devopstales.csr -subj "/CN=devopstales/O=devops-groupe"
</code></pre>
<p>对 csr 进行base64</p>
<pre><code class="language-bash">cat devopstales.csr | base64 | tr -d '\n'
</code></pre>
<p>把刚刚得到的 字符串 贴到 request 中, 然后创建 <code>CertificateSigningRequest</code></p>
<pre><code class="language-yaml">apiVersion: certificates.k8s.io/v1beta1
kind: CertificateSigningRequest
metadata:
  name: user-request-devopstales
spec:
  groups:
  - system:authenticated
  request: LS0tLS1CRUdJTi...
  usages:
  - digital signature
  - key encipherment
  - client auth
</code></pre>
<p>然后 approve 它</p>
<pre><code class="language-bash">kubectl create -f devopstales-csr.yaml
kubectl certificate approve user-request-devopstales
</code></pre>
<p>然后获取 证书</p>
<pre><code class="language-bash">kubectl get csr user-request-devopstales -o jsonpath='{.status.certificate}' | base64 -d &gt; devopstales-user.crt
</code></pre>
<p>然后创建对应的 kubeconfig 文件</p>
<pre><code class="language-bash">kubectl --kubeconfig ./config-devopstales config set-cluster preprod --insecure-skip-tls-verify=true --server=https://KUBERNETES-API-ADDRESS
kubectl --kubeconfig ./config-devopstales config set-credentials devopstales --client-certificate=devopstales-user.crt --client-key=devopstales.pem --embed-certs=true
kubectl --kubeconfig ./config-devopstales config set-context default --cluster=preprod --user=devopstales
kubectl --kubeconfig ~/.kube/config-devopstales config use-context default
</code></pre>
<p>最后创建 role/rolebinding</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Namespace
metadata:
  name: devopstales-ns
spec: {}
status: {}
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: devopstales
  namespace: devopstales-ns
rules:
- apiGroups: ["", "extensions", "apps"]
  resources: ["*"]
  verbs: ["*"]
- apiGroups: ["batch"]
  resources:
  - jobs
  - cronjobs
  verbs: ["*"]
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: devopstales
  namespace: devopstales-ns
subjects:
- kind: User
  name: devopstales
  apiGroup: rbac.authorization.k8s.io
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: devopstales
</code></pre>
<h2 id="用户组"><a class="header" href="#用户组">用户组</a></h2>
<p>用户组也是一个用户, 创建用户组还是要重复以上过程.</p>
<p>如果想要把某个用户划到用户组里, 需要在创建 <code>CertificateSigningRequest</code>时, 设置一下 <code>groups</code>, 例如:</p>
<pre><code class="language-yaml">apiVersion: certificates.k8s.io/v1beta1
kind: CertificateSigningRequest
metadata:
  name: user-request-devopstales
spec:
  groups:
  - mygroup
  request: LS0tLS1CRUdJTi...
  usages:
  - digital signature
  - key encipherment
  - client auth
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="linux-container"><a class="header" href="#linux-container">Linux Container</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="一份容器知识备忘录"><a class="header" href="#一份容器知识备忘录">一份容器知识备忘录</a></h1>
<h2 id="linux-namespace"><a class="header" href="#linux-namespace">Linux Namespace</a></h2>
<h3 id="linux-namespace-是什么"><a class="header" href="#linux-namespace-是什么">Linux Namespace 是什么？</a></h3>
<ul>
<li>UTS：隔离不同的机器名、域名</li>
<li>IPC：隔离 linux 消息队列</li>
<li>PID：隔离进程可见性（pid）</li>
<li>Mount：隔离挂载点</li>
<li>User：隔离用户以及用户组</li>
<li>Network：隔离网络（网络虚拟化）</li>
</ul>
<p>基于namespace，docker 就可以达到看起来像是独立于宿主机之外的效果</p>
<h3 id="怎么使用-namespace"><a class="header" href="#怎么使用-namespace">怎么使用 Namespace？</a></h3>
<p>系统调用：</p>
<ul>
<li>clone 创建新进程时，根据调用参数来创建该进程的namesapce，并且它的子进程也会包含在 namespace 中</li>
<li>unshare 将进程移除某个 namespace</li>
<li>setns 将进程加入某个 namespace</li>
</ul>
<h2 id="linux-cgroup"><a class="header" href="#linux-cgroup">Linux Cgroup</a></h2>
<h3 id="linux-cgroup-是什么"><a class="header" href="#linux-cgroup-是什么">Linux Cgroup 是什么？</a></h3>
<p>什么是Cgroup？</p>
<ul>
<li>subsystem 是各种控制模块
<ul>
<li>blkio：控制进程对硬盘的访问（例如输入/输出大小限制）</li>
<li>cpu：设置进程的cpu调度策略</li>
<li>cpuset：控制进程使用的多核cpu（所谓的 绑核）</li>
<li>devices：控制进程能够访问的设备</li>
<li>freezer：令进程挂起以及恢复</li>
<li>memory：控制进程访问内存</li>
<li>net_cls：网络包分类，以便 Linux tc (traffic controller ）可以根据分类区分出来自某个 cgroup 的包并做限流或监控</li>
<li>net_prio：控制进程的网络流量优先级</li>
<li>ns：它的作用是使 cgroup 中的进程在新的 Namespace fork新进 程 （NEWNS ）时，创建出 个新的cgroup ，这个 cgroup 包含新的 Namespace的进程</li>
</ul>
</li>
<li>cgroup：一个cgroup包含一组进程，通过subsystem与cgroup的关联，将这些进程与subsystem关联</li>
<li>hierarchy：将一组cgroup组成树状结构，通过这种结构，cgroup 可以继承父节点cgroup的subsystem属性</li>
</ul>
<p>基于 Cgroup，docker 可以达到控制进程资源的效果。</p>
<h3 id="怎么使用-cgroup"><a class="header" href="#怎么使用-cgroup">怎么使用 Cgroup？</a></h3>
<ul>
<li>Linux中 cgroup 以文件系统的方式暴露给用户，例如<code>mount -t cgroup cgroup ./cgroup_test/</code></li>
<li>系统自带的 Cgroup 路径<code>/sys/fs/cgroup</code></li>
</ul>
<h2 id="unionfs"><a class="header" href="#unionfs">UnionFS</a></h2>
<h3 id="unionfs-是什么"><a class="header" href="#unionfs-是什么">UnionFS 是什么？</a></h3>
<p>UnionFS是一类文件系统的统称，它可以将多个文件系统，视为同一个文件系统的不同branch，从而实现将不同目录的文件全部挂载到同一个目录上。什么意思？举个例子，有个目录是下面的结构</p>
<pre><code>data/
├── mongo
└── mysql
</code></pre>
<p>我有另外一个目录是这样的结构</p>
<pre><code>data/
├── protoc
└── golang
</code></pre>
<p>通过UnionFS可以将两个文件系统都挂在同一个目录下：</p>
<pre><code>data/
├── mongo
├── mysql
├── protoc
└── golang
</code></pre>
<p>当然以上是一种只读场景，当发生写入时，UnionFS使用了一种CoW的技术（copy-on-write 写时复制）。</p>
<blockquote>
<p>值得一提的是，系统调用中的 Fork 函数也使用了CoW的思想，fork 出子进程后，子进程的内存物理空间与父进程保持一致，直到子进程开始真正的修改时，才会复制对应的内存页</p>
</blockquote>
<p>当我们对一个文件进行写入时，我们并没有更改原来的文件，而是新增了一个 branch，在这个新的branch中，UnionFS会把原来的文件copy过来，并新增需要写入的内容。</p>
<p>通过这种方式，可以同时使用只读和可读写的文件系统，并且可以保持一定的低开销。两种常见的UnionFS的实现是<strong>AUFS</strong>和<strong>OverlayFS</strong></p>
<p>基于UnionFS，Docker 可以实现镜像分层（layer）以及镜像文件的重复利用</p>
<h3 id="怎么使用-unionfs-"><a class="header" href="#怎么使用-unionfs-">怎么使用 UnionFS ？</a></h3>
<p>使用系统调用 mount，以aufs为例：</p>
<pre><code class="language-bash">mount -t aufs -o dirs=/read-write-layer:/read-only-layer-1:/read-only-layer-2 none /mnt-dir
</code></pre>
<p>如何设置读写权限？左边第一个目录是 read-write 权限，其他的都是 read-only的</p>
<h2 id="解析-docker-的各种操作"><a class="header" href="#解析-docker-的各种操作">解析 docker 的各种操作</a></h2>
<h3 id="解析-docker-run-发生了什么"><a class="header" href="#解析-docker-run-发生了什么">解析 docker run 发生了什么？</a></h3>
<p>如何产生子进程</p>
<ul>
<li>fork 进程，同时创建新的 namespace，并开始 wait 子进程</li>
<li>fork 出的进程会调用自身（也就是 /proc/self/exe，这个路径会短链到当前的可执行文件），并在arg参中数增加 init 命令</li>
<li>init 命令会 exec 一个新的进程（注意exec 与fork 不同，exec 产生的子进程会完全替换当前的进程，包括数据、堆栈、PID等信息）</li>
<li>exec 产生的进程会执行 <code>mount proc</code>，并执行用户指定的 command 命令</li>
</ul>
<p>继续丰富上面过程中的细节，对子进程进行资源限制：</p>
<ul>
<li>执行 docker run，fork 子进程</li>
<li>根据用户参数，创建 Cgroup
<ul>
<li>cpu：写入cpu.shares文件</li>
<li>cpuset：写入cpuset.cpus</li>
<li>memory：写入memory.limit_in_bytes</li>
</ul>
</li>
<li>将子进程 pid 加入到创建 cgroup 中</li>
<li>wait 子进程</li>
</ul>
<p>继续丰富上面过程中的细节，通过管道向子进程传递参数：</p>
<ul>
<li>执行 docker run，fork 子进程</li>
<li>创建一个 pipe</li>
<li>将pipe的读取段，作为一个fd添加到子进程中</li>
<li>父进程在pipe写入端，写入数据</li>
<li>子进程读取 3号 fd</li>
<li>父进程 wait 子进程</li>
</ul>
<h3 id="docker-镜像是什么怎么使用"><a class="header" href="#docker-镜像是什么怎么使用">docker 镜像是什么？怎么使用？</a></h3>
<h4 id="镜像文件里有什么"><a class="header" href="#镜像文件里有什么">镜像文件里有什么？</a></h4>
<ul>
<li>
<p>manifest.json： 关于这个镜像包的一些配置，比如说镜像有哪几个 layer</p>
</li>
<li>
<ul>
<li>Config 文件：关于镜像本身的一些配置，比说 ENV，Entrypoint， Cmd</li>
</ul>
</li>
<li>
<p>layer：layer 一般是一个tar包，几个 layer 共同叠加之后组成一个 root 文件系统</p>
</li>
</ul>
<p>以 busybox 为例：</p>
<p>它的 manifest.json:</p>
<pre><code class="language-json">[
  {
    "Config": "d23834f29b3875b6759be00a48013ba523c6a89fcbaeaa63607512118a9c4c19.json",
    "RepoTags": [
      "busybox:latest"
    ],
    "Layers": [
      "2a7f8eb07ab44ffd8e11d364e8b7ad18f69df5f29e2e2eb13695e6b01fbb4f77/layer.tar"
    ]
  }
]
</code></pre>
<p>把它的layer解压之后得到目录:</p>
<pre><code>total 48
drwxr-xr-x 2 lubingtan lubingtan 12288 Nov 30 02:55 bin
drwxr-xr-x 4 lubingtan lubingtan  4096 Dec  5 12:47 dev
drwxr-xr-x 3 lubingtan lubingtan  4096 Dec  5 12:47 etc
drwxr-xr-x 2 lubingtan lubingtan  4096 Nov 30 02:55 home
drwxr-xr-x 2 lubingtan lubingtan  4096 Dec  5 12:47 proc
drwx------ 2 lubingtan lubingtan  4096 Nov 30 02:55 root
drwxr-xr-x 2 lubingtan lubingtan  4096 Dec  5 12:47 sys
drwxrwxr-x 2 lubingtan lubingtan  4096 Nov 30 02:55 tmp
drwxr-xr-x 3 lubingtan lubingtan  4096 Nov 30 02:55 usr
drwxr-xr-x 4 lubingtan lubingtan  4096 Nov 30 02:55 var
</code></pre>
<h4 id="怎么使用镜像"><a class="header" href="#怎么使用镜像">怎么使用镜像？</a></h4>
<p>使用镜像时怎么把读写 layer 分开？</p>
<ul>
<li>会新建一个 read-write 的 layer 以及一个 read-only 的 layer
<ul>
<li>这里 read-only 的 layer是用来存储启动容器时传入的系统信息</li>
</ul>
</li>
<li>把所有镜像的 layer 以及刚刚的两个 layer mount 到一个目录下，把这个目录作为容器的 root 目录</li>
</ul>
<p>容器启动时怎么使用新的 root 文件系统？</p>
<ul>
<li>系统调用 pivot_root 可以改变整个系统的 root 文件系统，从而移除对老 root 的依赖。</li>
<li>系统调用 chroot 是针对某个进程，其他进程还是老的 root</li>
<li>docker 会使用 pivot_root ，umouont 掉原来的 root</li>
</ul>
<p>这样就可以在容器内看到镜像的文件系统了。</p>
<p>整个流程：</p>
<ol>
<li>创建只读层</li>
<li>创建容器读写层</li>
<li>创建挂载点</li>
<li>将挂载点作为容器的root</li>
</ol>
<p>容器退出的时</p>
<ol>
<li>卸载挂载点</li>
<li>删除挂载点</li>
<li>删除除读写层</li>
</ol>
<h3 id="解析-docker-stoplogsdelete"><a class="header" href="#解析-docker-stoplogsdelete">解析 docker stop、logs、delete</a></h3>
<p>Stop：</p>
<ul>
<li>查找主进程 PID</li>
<li>发送 SIGTERM 信号 （kill -15）</li>
<li>等待进程结束，如果一直不结束，发送 SIGKILL （kill -9）</li>
<li>修改容器信息，写入存储容器信息的文件</li>
</ul>
<p>Delete：</p>
<ul>
<li>根据容器名查找容器信息。</li>
<li>判断容器是否处于停止状态。</li>
<li>查找容器存储信息的地址。</li>
<li>移除记录容器信息的文件。</li>
</ul>
<p>Logs：</p>
<ul>
<li>把stdout、stderr重定向到一个日志文件</li>
<li>找到容器对应的文件，输出。</li>
</ul>
<h3 id="解析-docker-commit"><a class="header" href="#解析-docker-commit">解析 docker commit</a></h3>
<ul>
<li>容器的进程会被 pause</li>
<li>重新打包当前的 root 文件系统</li>
</ul>
<h3 id="解析-docker-exec"><a class="header" href="#解析-docker-exec">解析 docker exec</a></h3>
<ul>
<li>使用了一个系统调用 <code>setns</code>能够进入目标进程的 namespace</li>
</ul>
<h2 id="linux-网络虚拟化"><a class="header" href="#linux-网络虚拟化">Linux 网络虚拟化</a></h2>
<p>Linux 网络虚拟化以及独赢的容器网络是有很多种形式的，在书中只介绍了 veth + bridge 这中容器网络方案。</p>
<h3 id="veth是什么"><a class="header" href="#veth是什么">Veth是什么？</a></h3>
<ul>
<li>veth 可以理解为虚拟网卡，它是成对出现的，即一个发送端、一个接收端，它可以用来连接不同 network namespace</li>
<li>如何操作：</li>
</ul>
<pre><code class="language-bash"># 创建 network namespace
ip netns add ns1
ip netns add ns2
# 创建一对 veth
ip link add veth0 type veth peer name veth1
# 把两个 veth 添加到两个 namespace 中
ip link set veth0 netns ns1
ip link set veth1 netns ns2
# 查看 ns1 的网络设备
ip netns exec ns1 ip link
# 配置 veth 的ip, 以及 namespace 的路由
ip netns exec ns1 ifconfig veth0 172.17.0.2/24 up
ip netns exec ns1 route add default dev veth0
ip netns exec ns2 ifconfig veth1 172.17.0.3/24 up
ip netns exec ns2 route add default dev veth1
# 对 veth 设备进行 ping
ip netns exec ns1 ping -c 1 172.18.0.3
</code></pre>
<h3 id="bridge-是什么"><a class="header" href="#bridge-是什么">bridge 是什么？</a></h3>
<ul>
<li>bridge 相当于一个虚拟的交换机，可以连接不同的网络设备。通过 bridge 可以连接 namespace 中的网络设备和宿主机上的网络。</li>
</ul>
<pre><code class="language-bash"># 创建 namespace 以及 veth
ip netns add ns1
ip link add veth0 type veth peer name veth1
# 将其中一个移到 ns1
ip link set veth1 setns ns1
# 创建网桥
brctl addbr br0
# 挂载网络设备
brctl addif br0 eth0
brctl addif br0 veth0
</code></pre>
<h3 id="路由表是什么"><a class="header" href="#路由表是什么">路由表是什么？</a></h3>
<ul>
<li>路由表是内核中的一个模块，通过定义路由表来决定在某个 namespace 中包的流向</li>
</ul>
<pre><code class="language-bash"># 启动虚拟网络设备, 并设置 veth 在 ns 中的IP
ip link set veth0 up
ip link set br0 up
ip netns exec ns1 ifconfig veth1 172.18.0.2/24
# 设置 ns1 网络空间的路由和宿主机上的路由
# default 代表 0.0.0.0/0, 即在 net namespace 中所有的流量都经过 veth1
ip netns exec ns1 route add default dev veth1
# 在宿主机上, 将流向 172.18.0.2/24 网段的请求, 全部路由到 br0 上ss
route add -net 172.18.0.2/24 dev br0
# 从 ns 访问宿主机
ip netns exec ns1 ping -c 10.0.2.15
# 宿主机访问 ns
ping -c 172.18.0.2
</code></pre>
<h3 id="iptables-是什么"><a class="header" href="#iptables-是什么">Iptables 是什么？</a></h3>
<p>iptables 是对内核中的 netfilter 模块进行操作的工具，可以用来管理流量包的流动和传送，通过不同的策略对包进行加工、传送或丢弃。例如：</p>
<ul>
<li>MASQUERADE 策略：将请求包的源地址换成一个网络设备的地址。这个用到的场景是，ns 中的请求包到达宿主机外部后，不知道如何访问这个请求包的源地址。如果使用这个策略将源地址替换，就可以找到宿主机了。</li>
<li>DNAT 策略：可以将 ns 内部的端口映射到宿主机端口，这样外部请求到达时，就可以访问ns中的网络了。</li>
</ul>
<h2 id="docker-的容器网络"><a class="header" href="#docker-的容器网络">Docker 的容器网络</a></h2>
<h3 id="golang-中如何实现"><a class="header" href="#golang-中如何实现">golang 中如何实现</a></h3>
<ul>
<li>net 库</li>
<li>netlink 库</li>
<li>netns 库</li>
</ul>
<h3 id="docker-对于容器网络的抽象"><a class="header" href="#docker-对于容器网络的抽象">Docker 对于容器网络的抽象</a></h3>
<ul>
<li>网络：是容器的集合，在这个网络上的容器可以通过这个网络互相通信，就像挂载到同一个 Linux Bridge 设备上的网络设备一样。网络中会包括这个网络相关的配置，比如网络的容器地址段、网络操作所调用的网络驱动等信息。</li>
<li>网络端点：连接容器与网络，凹征容器内部与网络的通信。例如Veth设备，一端挂在容器内部，一端挂在 Bridge 上，就能保证容器和网络的通信。网络端点中包括连接到网络的一些信息，比如地址、Veth 设备、端口映射、连接的容器和网络等信息。</li>
<li>网络驱动：网络功能中的组件，不同驱动代表者对网络创建、连接、销毁的不同策略。创建网络时指定不同的网络驱动来定义如何做网络的配置。</li>
<li>IPAM：也是网络功能中的组件，用于网络 IP 地址的分配和释放，包括容器的 IP 地址和网络网关的 IP 地址。它的功能时从指定的 subnet 网段中分配 IP 地址，以及释放 IP 地址。</li>
</ul>
<h3 id="如何分配ip"><a class="header" href="#如何分配ip">如何分配IP？</a></h3>
<ul>
<li>基于 bitmap 算法：把一段 ip 是否已经分配的状态，保存在一段二进制数字中（已分配为 1，未分配为 0）</li>
<li>分配 ip 时把 ip 地址的信息记录到文件中</li>
</ul>
<h3 id="如何创建网络"><a class="header" href="#如何创建网络">如何创建网络？</a></h3>
<p>创建网络：</p>
<ul>
<li>输入网络的网段、网关以及网络的名字</li>
<li>创建 bridge 设备</li>
<li>设置 bridge 设备的地址和路由</li>
<li>启动 bridge 设备</li>
<li>设置 iptabels 的 SNAT 规则</li>
</ul>
<p>删除网络：</p>
<ul>
<li>删除 bridge 设备</li>
</ul>
<h3 id="如何把容器连上网络"><a class="header" href="#如何把容器连上网络">如何把容器连上网络？</a></h3>
<ul>
<li>创建 veth</li>
<li>挂载一端到 bridge 上</li>
<li>挂载另一端到 network ns 中</li>
<li>设置另一端的 ip</li>
<li>设置 network ns 中的路由</li>
<li>设置端口映射</li>
</ul>
<h3 id="如何容器之间跨主机通信"><a class="header" href="#如何容器之间跨主机通信">如何容器之间跨主机通信？</a></h3>
<ul>
<li>通过一致性 kv-store 分配 ip</li>
<li>通过封包或者路由实现跨主机通信
<ul>
<li>封包：将请求包封装成宿主机直接的通信包，在宿主机解包后再发送到对应的容器
<ul>
<li>vxlan</li>
<li>gre</li>
</ul>
</li>
<li>路由：让宿主机网络知道容器的地址要怎么路由，需要网络设备的支持
<ul>
<li>路由器路由表</li>
<li>Vlan</li>
<li>VPC路由表</li>
<li>macvlan：<strong>一块物理网卡虚拟成多块虚拟网卡</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="业界主流技术栈"><a class="header" href="#业界主流技术栈">业界主流技术栈</a></h2>
<h3 id="runc"><a class="header" href="#runc">runC</a></h3>
<p>runc 的目标是，构造到处都可以运行的标准容器</p>
<ul>
<li>由docker 的子项目 libcontainer 发展而来，托管于OCI（open container Initiative，2015年成立的组织）</li>
<li>完全支持 Linux Namespace</li>
<li>支持所有 Linux 所有原生安全特性（Selinux、prvot_root、capability等等）</li>
<li>支持容器热迁移（CRIU项目）</li>
<li>正式的容器标准以及实现</li>
<li>OCI 标准
<ul>
<li>rootfs 一个文件夹， 代表容器的 root 文件系统</li>
<li>config.json 包括容纳容器的配置数据</li>
</ul>
</li>
</ul>
<h4 id="容器配置里有什么"><a class="header" href="#容器配置里有什么">容器配置里有什么？</a></h4>
<ul>
<li>mounts：挂载点，源设备名或者文件名，目标挂载路径，等等</li>
<li>process：比如工作目录，环境变量，启动命令，资源使用量等等。</li>
<li>user：容器内的用户信息</li>
<li>platform：容器运行的系统信息</li>
<li>hook 钩子
<ul>
<li>prestart：在容器启动之后、用户进程启动之前执行，可以配置一些容器初始化环境。
<ul>
<li>典型的例如，nvidia container runtime，它在 runc 之上包了一层，把一个 prestart hook 传递给runc，这个 prestart hook 其实是一个叫做 nvidia-container-toolkit 的 cli 程序，这个cli 调用了 libnvidia-contaiener 来做一些初始化环境的工作。</li>
</ul>
</li>
<li>poststart：在用户进程启动之后执行，例如提醒用户容器已经起来了。</li>
<li>poststop：在容器进行停止后执行，可以用来做一些清理工作。</li>
</ul>
</li>
</ul>
<h4 id="runc-是怎么创建容器的"><a class="header" href="#runc-是怎么创建容器的">runc 是怎么创建容器的？</a></h4>
<ol>
<li>读取配置文件</li>
<li>设置 rootfs</li>
<li>使用factory 创建容器（不同系统不同的实现）</li>
<li>创建初始化进程</li>
<li>设置容器的输出管道</li>
<li>启动 container.Start 启动物理的容器</li>
<li>回调 init 方法重新初始化容器进程</li>
<li>runC 父进程等待子进程，结束后退出</li>
</ol>
<h4 id="oci-标准还有什么东西"><a class="header" href="#oci-标准还有什么东西">OCI 标准还有什么东西？</a></h4>
<p><a href="https://github.com/opencontainers/image-spec">image-spec</a>：定义了镜像保存的格式</p>
<p><a href="https://github.com/opencontainers/distribution-spec">distribution-spec</a>：定义了镜像仓库的接口</p>
<h3 id="docker-containerd"><a class="header" href="#docker-containerd">Docker containerd</a></h3>
<ul>
<li>作为 daemon 程序（守护进程）运行在 Linux 上，管理机器上所有容器的生命周期</li>
<li>从 docker 项目中独立出来的，向更上层的平台暴露 gRPC API，例如 Swram、Kubernetes、Mesos等等</li>
<li>containerd 负责一台机器的 镜像操作（pull / push）、容器操作（start / stop）、网络以及存储，不过对于容器具体的运行是由 runC 负责
<ul>
<li>支持 OCI 运行时</li>
<li>支持镜像 pull / push</li>
<li>容器运行时生命周期管理</li>
<li>网络操作原语</li>
<li>存储</li>
</ul>
</li>
</ul>
<p>Containerd 的架构：</p>
<p><img src="docs/images/自己动手写docker读书笔记/image-20211205151345214.png" alt="image-20211205151345214"></p>
<h4 id="containerd-和-docker-之间的关系"><a class="header" href="#containerd-和-docker-之间的关系">containerd 和 docker 之间的关系？</a></h4>
<ul>
<li>docker 包含 containerd，除了containerd 的 功能之外，docker 还可以完成镜像构建的功能，以及 docker client 提供的 cli 工具</li>
</ul>
<h4 id="containerd和-ocirunc-之间的关系"><a class="header" href="#containerd和-ocirunc-之间的关系">containerd和 OCI、runc 之间的关系？</a></h4>
<p>OCI 个标准化的容器规范，包括运行时规范和镜像规范 rune 是基于此规范的参考实现， Docker 贡献了 runc 主要代码。</p>
<p>从技术枝上看 containerd 比 runc 的层次更高， containerd 可以使用 runc 启动容器，还可以下载镜像，管理网络。</p>
<h3 id="cri-以及-shim-层"><a class="header" href="#cri-以及-shim-层">CRI 以及 shim 层</a></h3>
<p>CRI 是 k8s（容器编排）这个项目定义的一组接口，可以让 kubelet 通过 CRI 接口进行容器操作。</p>
<h4 id="cri-的接口定义有哪些"><a class="header" href="#cri-的接口定义有哪些">CRI 的接口定义有哪些？</a></h4>
<p>CRI 的核心概念：PodSandbox 和 Container：</p>
<ul>
<li>pod 由一组 Container 构成，这些容器贡献相同的环境与资源，这个共同的环境被称为 PodSandbox</li>
<li>不同的实现可以由不同的 PodSandbox，比如 docker 可以实现成一个 namespace，Hypervisor 可以实现成一个虚拟机。</li>
</ul>
<p>定义：<a href="https://github.com/kubernetes/cri-api/blob/master/pkg/apis/runtime/v1/api.proto">cri-api/api.proto at master · kubernetes/cri-api</a></p>
<ul>
<li>RuntimeService：Pod 、容器以及日志的操作</li>
<li>ImageService：镜像的操作（不包括 build）</li>
</ul>
<h4 id="使用-cri-有什么好处"><a class="header" href="#使用-cri-有什么好处">使用 CRI 有什么好处？</a></h4>
<ul>
<li>解耦了 Pod 的实现与接口，开发 shim 时不需要了解 kubelet</li>
<li>有利于 kubelet 的扩展</li>
</ul>
<p>CRI 的目的在于：</p>
<ul>
<li>提升 Kubernetes 可扩展性，让更多的容器运行时更容易集成到 Kubernetes 中。</li>
<li>提升 Pod Feature 的更新迭代效率。</li>
<li>构建易于维护的代码体系。</li>
</ul>
<p>CRI 不会做以下5件事。</p>
<ul>
<li>
<p>建议如何与新的容器运行时集成，例如决定 Container Shim 应该在哪里实现。</p>
</li>
<li>
<p>提供新接口的版本管理。</p>
</li>
<li>
<p>提供 Windows container 支持。本接口不会在 Windows container 支持方面花费太多，但会尽量做到更加易于扩展来让 Windows container 特性更容易被添加进来。</p>
</li>
<li>
<p>重新定义 Kubelet 的内部运行时相关接口。尽管会增加 Kubelet 可维护性，但这不是 CRI 的工作。</p>
</li>
<li>
<p>提升 Kubelet 效率和性能。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="inference"><a class="header" href="#inference">Inference</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="model-mesh-serving-一种可以大规模部署ml模型的解决方案-1"><a class="header" href="#model-mesh-serving-一种可以大规模部署ml模型的解决方案-1">Model Mesh Serving: 一种可以大规模部署ML模型的解决方案</a></h1>
<h2 id="what-is-model-mesh-serving"><a class="header" href="#what-is-model-mesh-serving">What Is Model Mesh Serving</a></h2>
<h3 id="背景-inference-service-in-mlops"><a class="header" href="#背景-inference-service-in-mlops">背景: Inference Service in MLOps</a></h3>
<p>作为一个算法工程师/Data scientist, 往往希望在训练结束后, 能够快速的把模型部署在服务器中, 这样就能让模型很方便的接收外部请求并返回预测结果.</p>
<p>基于这种需求, <a href="https://github.com/tensorflow/serving">Tensorflow Serving</a>, <a href="https://github.com/pytorch/serve">TorchServe</a>, <a href="https://github.com/triton-inference-server/server">Triton Inference Server</a>, <a href="https://github.com/microsoft/onnxruntime/blob/master/docs/ONNX_Runtime_Server_Usage.md">ONNX Runtime Server</a> 等各种 model inference server 开始出现.</p>
<p>不过随着技术以及业务规模的发展, 我们的需求也变得更多, 我们不仅希望把模型部署在服务器上, 更希望能够非常简单的集成<strong>日志/监控/服务发现/负载均衡</strong>等功能, 以及能够非常方便的进行<strong>金丝雀发布/滚动更新</strong>等各种运维操作.</p>
<p>这里有两种思路:</p>
<ul>
<li>
<p>第一种思路就是, 把 model server 当作是一种普通的后端服务:</p>
<p>在这种方案中, AI 工程师需要了解大量和以上功能相关的知识, 或者也可以将模型交付给后端工程师. 然而不管那种方式, 显然都增加了大量的时间以及沟通成本. 并且公司内不同的团队使用不同的框架/接口协议, 这些都会造成额外的接入成本.</p>
</li>
<li>
<p>另一种思路是, 把 model server 当作一种特殊的后端服务:</p>
<p>由 AI 工程师以及后端工程师共同组成一支团队,  建设一个专门用于模型部署的平台. 对于所有模型都以一种标准化的方式进行管理, 并且提供一系列工具对于模型的部署/更新/优化等操作进行封装及简化. 利用这些平台工具, 不同团队的AI工程师都可以非常方便的对于模型进行发布. 这样就可以大大较少模型交付以及迭代的成本.</p>
</li>
</ul>
<p>基于第二种思路, 当前已经出现了一些可用于构建推理平台的开源项目, 例如 <a href="https://github.com/kserve/kserve">kfserving</a> (已经改名为 kserve, 并从 kubeflow 独立出来), <a href="https://github.com/SeldonIO/seldon-core">Seldon Core</a>.</p>
<p>关于这些方案, 具体细节这里就不再赘述了, 感兴趣的同学可以到 github 上进一步了解.</p>
<blockquote>
<p>不过, 笔者认为它们并非是完美的方案, 它们的底层都使用了 trtion, tfserving 等这些 model server, 但是并没有发挥出这些 model server 的全部特性.</p>
</blockquote>
<h3 id="ibm-开源的方案-model-mesh-serving"><a class="header" href="#ibm-开源的方案-model-mesh-serving">IBM 开源的方案: Model Mesh Serving</a></h3>
<p><a href="https://github.com/kserve/modelmesh-serving">Model Mesh Serving</a> 是IBM开源的模型推理方案, 据说已经在内部平稳运行多年了, 现在已经开源, 并作为一个子项目加入了 kserve.</p>
<p>Model Mesh Serving  旨在解决 ‘one model one server’ 模式 (也是kserve和seldon采用的方案) 的弊端:</p>
<ul>
<li>无法最大限度的有效利用资源</li>
<li>节点上的 Pod 数量是有限的 (100+)</li>
<li>集群的 IP 数量是有限的, 从而导致模型的数量也是有限的</li>
</ul>
<p>Model Mesh Serving  提供了以下一些 feature:</p>
<ul>
<li>
<p>Scalability: 使用 multi-model server, 能够以少量 pod 加载大量模型</p>
</li>
<li>
<p>Cache managerment and HA</p>
<ul>
<li>
<p>管理模型的机制类似于 LRU cache, 动态的加载/卸载模型, 如果某个模型的访问负载很高, 就将它copy到多个 server 实例 (pod)</p>
</li>
<li>
<p>在模型的 copies 之间做 负载均衡/路由转发</p>
</li>
<li>
<p>retrying/rerouting failed requests</p>
</li>
</ul>
</li>
<li>
<p>Intelligent placement and loading</p>
<ul>
<li>加载模型时, 在多个 pod 之间做均衡: 把负载高的模型放到负载小的 pod 中</li>
</ul>
</li>
<li>
<p>Resiliency</p>
<ul>
<li>加载模型失败时, 会在其他 pod 上做重试</li>
</ul>
</li>
<li>
<p>Operational simplicity:</p>
<ul>
<li>模型可以进行滚动更新, 对于 requests 无感</li>
</ul>
</li>
</ul>
<p>Model Mesh Serving 包含的组件</p>
<ul>
<li><code>ServingRuntime</code>: Triton, MLServer, etc</li>
<li><code>ModelMesh</code>: Mesh Layer</li>
<li><code>Runtime Adapters</code>: Adapters to different runtimes</li>
<li><code>ModelMesh Serving</code>: Controller for mesh , runtime , predictor</li>
</ul>
<p><img src="docs/Machine_Learning/images/modelmesh/0.2.0-highlevel.png" alt="0.2.0-highlevel.png"></p>
<p><img src="docs/Machine_Learning/images/modelmesh/rt-builtin.png" alt="rt-builtin.png"></p>
<blockquote>
<p>参考: <a href="https://developer.ibm.com/blogs/kserve-and-watson-modelmesh-extreme-scale-model-inferencing-for-trusted-ai/">ModelMesh and KServe bring eXtreme scale standardized model inferencing on Kubernetes – IBM Developer</a></p>
</blockquote>
<h2 id="how-model-mesh-works"><a class="header" href="#how-model-mesh-works">How Model Mesh Works</a></h2>
<h3 id="model-mesh-layer"><a class="header" href="#model-mesh-layer">Model Mesh Layer</a></h3>
<p>Model Mesh 的核心就是实现了以下几个 rpc 接口:</p>
<pre><code class="language-protobuf">service ModelMesh {
  // Creates a new vmodel id (alias) which maps to a new or existing
  // concrete model, or sets the target model for an existing vmodel
  // to a new or existing concrete model
  rpc setVModel (SetVModelRequest) returns (VModelStatusInfo) {}

  // Deletes a vmodel, optionally deleting any referenced concrete
  // models at the same time
  rpc deleteVModel (DeleteVModelRequest) returns (DeleteVModelResponse) {}

  // Gets the status of a vmodel, including associated target/active model ids
  // If the vmodel is not found, the returned VModelStatusInfo will have empty
  // active and target model ids and an active model status of NOT_FOUND
  rpc getVModelStatus (GetVModelStatusRequest) returns (VModelStatusInfo) {}
}
</code></pre>
<p>下面介绍 modelmesh 中的几个关键概念以及实现.</p>
<h4 id="vmodel-virtual-model-是什么"><a class="header" href="#vmodel-virtual-model-是什么">VModel (virtual model) 是什么?</a></h4>
<ul>
<li>
<p>可以把 VModel 理解为某一类模型 (例如 人脸识别模型/bert 模型等等), 同时 Model 是具体的某一个模型 (每个具体的模型有不同的参数以及对应的模型文件)</p>
<ul>
<li>model mesh 通过 model id 标记 VModel , 通过 target id 标记 Model. 也就是说 VModel 下所属的每个 Model 都有相同的 model id, 但是有不同的 target id</li>
</ul>
</li>
<li>
<p>model mesh 通过对 VModel + Model 的管理, 实现了模型的发布管理 (有点像 k8s 中的 deployment)</p>
</li>
</ul>
<h4 id="模型是如何被加载的"><a class="header" href="#模型是如何被加载的">模型是如何被加载的?</a></h4>
<p>调用stack:</p>
<ol>
<li>ModelMeshAPI 暴露 setVModel 接口</li>
<li>setVModel 中, 调用了 VModelMananger 的 updateVModel, updateVModel 修改 etcd 上的 Model 记录</li>
<li>ModelMesh watch 到 Model Update Event, 执行 VModelManager 的 processVModel</li>
<li>processVModel 中执行 ensureLoaded →  internalOperation → invokeModel →
<ul>
<li>invokeLocalModel → 本地执行 model runtime client
<ul>
<li>model runtime client 是一个 GRPC client, 执行同一个 pod 的 runtime 容器</li>
<li>把请求缓存到一个 <code>loadingQueue</code>中 (loadingQueue 是一个优先队列)</li>
<li>默认异步执行, 如果需要同步执行, 提高优先级, 并等待.</li>
</ul>
</li>
<li>invokeRemote → 执行  remoteClient 或 cacheMissClient (远程 model mesh)
<ul>
<li>runtimeClient  负载均衡策略:  选择很久没用过的节点 (last recently used 最小的)</li>
<li>cacheMissClient 的 lb 策略: 从 prefer 的 instance 中随机选择一个</li>
</ul>
</li>
<li>forwardInvokeModel → 执行 directClient (远程 model mesh)
<ul>
<li>directClient 是一个 Thrift RPC client, 指向上次 (runtimeClient/cacheMissClient) 选择的 model mesh 实例.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>invokeModel 的逻辑 (非常复杂):</p>
<ol>
<li>如果设置了 Local  flag, 在本地执行, 如果模型不在本地, 会抛出错误</li>
<li>如果请求有 copy 的 flag, 说明需要复制模型, 加上 unbalanced flag, 递归执行 invokeModel</li>
<li>根据 exclude 参数 (从请求的 context 里获取的), 过滤所有 instance</li>
<li>如果存在可选的 instance, 则根据各种参数判断 需要在本地执行还是远程执行 (比如请求已经被 balaced 了, 则在本地执行)</li>
<li>如果不存在可选的 instance, 说明出现了 cache miss
<ol>
<li>如果来自集群外部的请求, 使用  cacheMissClient  执行.</li>
<li>如果不是, 则在本地执行</li>
</ol>
</li>
</ol>
<h4 id="如何对-inference-请求进行路由转发的"><a class="header" href="#如何对-inference-请求进行路由转发的">如何对 inference 请求进行路由转发的?</a></h4>
<ul>
<li>
<p>model mesh 中实现了一个 grpc 代理, 对于带有特定 metadata 的请求进行转发</p>
<blockquote>
<p><a href="https://github.com/kserve/modelmesh-serving/blob/main/docs/predictors/run-inference.md">run-inference.md</a>: you should include an additional metadata parameter <code>mm-balanced = true</code>.</p>
</blockquote>
</li>
<li>
<p>服务启动: NettyServerBuilder → addService → new ServerInterceptor</p>
</li>
<li>
<p>接口调用stack: interceptCall →  startCall → ModelMesh.callModel → SidecarModelMesh.callModel → <strong>invokeModel</strong></p>
</li>
</ul>
<h3 id="model-runtime-adapters"><a class="header" href="#model-runtime-adapters">Model Runtime Adapters</a></h3>
<p>Model Runtime Adapters 实现了<code>ModelRuntime</code> 的接口, 并且适配真正的 ModelServer (例如 triton, mlserver, tfserving)</p>
<pre><code class="language-protobuf">service ModelRuntime {
  rpc loadModel (LoadModelRequest) returns (LoadModelResponse) {}

  rpc unloadModel (UnloadModelRequest) returns (UnloadModelResponse) {}

  // Predict size of not-yet-loaded model - must return almost immediately.
  // Should not perform expensive computation or remote lookups.
  // Should be a conservative estimate.
  rpc predictModelSize (PredictModelSizeRequest) returns (PredictModelSizeResponse) {}

  // Calculate size (memory consumption) of currently-loaded model
  rpc modelSize (ModelSizeRequest) returns (ModelSizeResponse) {}
  rpc runtimeStatus (RuntimeStatusRequest) returns (RuntimeStatusResponse) {}
}
</code></pre>
<p>实现逻辑非常简单, 以  <code>model-mesh-triton-adapter</code>为例:</p>
<p>LoadModel:</p>
<ol>
<li>下载模型(同步)</li>
<li>根据模型类型, 重新设置模型文件名以及路径 (比如 triton 就有些特殊要求, onnx 模型的名字为 model.onnx)</li>
<li>向 model server 发送请求 (triton 的load 接口: RepositoryModelLoad)</li>
<li>返回结果</li>
</ol>
<h3 id="model-mesh-seving"><a class="header" href="#model-mesh-seving">Model Mesh Seving</a></h3>
<p>Model Mesh Serving 就是 ModelMesh 的controller plane, 它控制了两个 CRD: Predictor 以及 ServingRuntime.</p>
<p>它的功能有:</p>
<ol>
<li>Watch ServiceRuntime, 创建带有 Model Mesh container 的 Deployment</li>
<li>Watch predictor, 访问 Model Mesh 实例, 发送 setVModel/deleteVModel/getVModelStatus 请求</li>
<li>Watch Etcd 中对应 VModel/Model 的 key-value, 转换为 predictor 的 name, 塞进 predictor controller 中处理.</li>
<li>维护 ModelMesh client 以及对应的 grpc resolver</li>
</ol>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>感觉 ModelMesh 的想法非常好, 这才是<strong>AI推理服务</strong>的 Serverless !</p>
<p>不过, 感觉这个项目目前还不太成熟.</p>
<ul>
<li>只能支持单个 namespace 的 model mesh, 每扩展一个namespace 就要操作一把, 非常不友好.</li>
<li>需要一个额外的 etcd (在 k8s 之外), 这一点让人感觉非常别扭, 也增加了维护成本.</li>
<li>ModelMesh 作为最重要的组件居然是用 java 写的 (其他都是go), 而且用了一个 IBM 自己的 java 框架 (根本没人用). 可以理解, 但是作为开源项目, 感觉对项目的推广非常不友好.</li>
</ul>
<p>总的来说, 感觉这个项目还是值得一看的. 另外看到matainer也在积极推进项目的发展 (比如说支持多namespace), 希望能早日到达生产可用的状态.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="development-environment"><a class="header" href="#development-environment">Development Environment</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="docker环境配置-1"><a href="#docker环境配置-1" class="header">Docker环境配置</a></h1>
<h2 id="docker-安装"><a class="header" href="#docker-安装">Docker 安装</a></h2>
<h3 id="在ubuntuwsl中安装"><a class="header" href="#在ubuntuwsl中安装">在Ubuntu/WSL中安装</a></h3>
<h4 id="更换apt源optional"><a class="header" href="#更换apt源optional">更换apt源(Optional)</a></h4>
<p>/etc/apt/sources.list替换</p>
<pre><code class="language-bash">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal universe
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates universe
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security universe
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security multiverse
</code></pre>
<p>arm64</p>
<pre><code># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-updates main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-backports main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-security main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-security main restricted universe multiverse

# 预发布软件源，不建议启用
# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-proposed main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-proposed main restricted universe multiverse
</code></pre>
<h4 id="查看docker可用版本"><a class="header" href="#查看docker可用版本">查看docker可用版本</a></h4>
<pre><code>apt-cache madison docker
</code></pre>
<h4 id="安装docker"><a class="header" href="#安装docker">安装docker</a></h4>
<h5 id="安装最新版本"><a class="header" href="#安装最新版本">安装最新版本</a></h5>
<pre><code class="language-bash">curl -fsSL https://get.docker.com -o get-docker.sh
sudo bash get-docker.sh
sudo service docker start
</code></pre>
<h5 id="安装特定版本"><a class="header" href="#安装特定版本">安装特定版本</a></h5>
<pre><code class="language-Bash"># 卸载
sudo apt-get remove docker docker-engine docker.io
sudo apt-get purge docker docker-engine docker.io
sudo apt-get update
sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    software-properties-common
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"
sudo apt-get update
# 查看docker-ce所有版本
sudo apt-cache madison docker-ce
# 选择一个版本进行安装
sudo apt-get install docker-ce=18.03.0~ce-0~ubuntu
</code></pre>
<h5 id="配置非root使用docker"><a class="header" href="#配置非root使用docker">配置非root使用docker</a></h5>
<pre><code class="language-Bash">sudo groupadd docker
sudo gpasswd -a ${USER} docker
sudo service docker restart
newgrp - docker
</code></pre>
<h3 id="在mac中安装"><a class="header" href="#在mac中安装">在Mac中安装</a></h3>
<h4 id="docker-desktop"><a class="header" href="#docker-desktop">Docker Desktop</a></h4>
<p><a href="https://docs.docker.com/desktop/setup/install/mac-install/">Mac | Docker Docs</a></p>
<h4 id="rancher-desktop"><a class="header" href="#rancher-desktop">Rancher Desktop</a></h4>
<p><a href="https://docs.rancherdesktop.io/getting-started/installation">Installation | Rancher Desktop Docs</a></p>
<h4 id="使用虚拟机"><a class="header" href="#使用虚拟机">使用虚拟机</a></h4>
<p>这里只列举一种虚拟机, 使用 multipass <a href="https://github.com/canonical/multipass">canonical/multipass: Multipass orchestrates virtual Ubuntu instances (github.com)</a></p>
<p>官方文档: <a href="https://multipass.run/install">Multipass orchestrates virtual Ubuntu instances</a></p>
<p>如何 ssh 进去:</p>
<p><a href="https://techsparx.com/linux/multipass/enable-ssh.html">How to enable passwordless SSH login on Ubuntu 20.04 that’s inside Multipass (techsparx.com)</a></p>
<h2 id="配置docker使用proxy"><a class="header" href="#配置docker使用proxy">配置Docker使用Proxy</a></h2>
<h3 id="docker-daemon-配置-proxy"><a class="header" href="#docker-daemon-配置-proxy">docker daemon 配置 proxy</a></h3>
<p>查看system service 文件地址</p>
<pre><code class="language-sh">~$ sudo systemctl cat docker
# /lib/systemd/system/docker.service
</code></pre>
<p>增加额外的配置</p>
<pre><code class="language-sh"># mkdir /lib/systemd/system/docker.service.d
# cat  /lib/systemd/system/docker.service.d/http-proxy.conf
[Service]
Environment="https_proxy=http://192.168.32.1:7897"
Environment="http_proxy=http://192.168.32.1:7897"
</code></pre>
<p>重启docker</p>
<pre><code class="language-sh">systemctl daemon-reload
systemctl restart docker
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows开发环境配置-1"><a href="#windows开发环境配置-1" class="header">WIndows开发环境配置</a></h1>
<h2 id="wsl"><a class="header" href="#wsl">WSL</a></h2>
<h3 id="切换wsl版本"><a class="header" href="#切换wsl版本">切换wsl版本</a></h3>
<p>管理员运行：</p>
<p><code>wsl --set-version Ubuntu 2</code></p>
<h3 id="wsl-无法访问windonws-host-上的服务"><a class="header" href="#wsl-无法访问windonws-host-上的服务">WSL 无法访问windonws host 上的服务</a></h3>
<h4 id="networkmodenat"><a class="header" href="#networkmodenat">networkMode=NAT</a></h4>
<p>原因是 Windows 防火墙阻止了访问, 查看这个<a href="https://github.com/microsoft/WSL/issues/4585">issue</a></p>
<pre><code class="language-sh">New-NetFirewallRule -DisplayName "WSL" -Direction Inbound  -InterfaceAlias "vEthernet (WSL)"  -Action Allow
</code></pre>
<h4 id="networkmodemirrored"><a class="header" href="#networkmodemirrored">networkMode=mirrored</a></h4>
<p>另一种方法： https://zhuanlan.zhihu.com/p/15762609815
把 network 模式设置为 mirrored</p>
<p>同时最好打开 hostAddressLoopback，能够允许使用 IP 访问（否则只能用localhost或者127.0.0.1）</p>
<p>最终的<code>.wslconfig</code>:</p>
<pre><code class="language-toml">[wsl2]
networkingMode=Mirrored
[experimental]
hostAddressLoopback=true
</code></pre>
<h3 id="使用vpn代理时的问题"><a class="header" href="#使用vpn代理时的问题">使用VPN代理时的问题</a></h3>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>这里的vpn并不是平常用的 http/https/socks5 proxy，指的是一般公司里使用的、用来访问 private network 的代理</p>
<p>如果需要在wsl中访问 host 上的proxy， 参考<a href="#wsl-无法访问windonws-host-上的服务">这里</a></p>
</blockquote>
<h4 id="wls2-启动不了"><a class="header" href="#wls2-启动不了">WLS2 启动不了</a></h4>
<p>参考这个issue https://github.com/microsoft/WSL/issues/4177#issuecomment-508826708</p>
<p>下载NoLsp： https://www.proxifier.com/tmp/Test20200228/NoLsp.exe</p>
<p>然后<strong>管理员权限</strong>启动PowerShell，然后执行：</p>
<p><code>.\NoLsp.exe c:\windows\system32\wsl.exe</code></p>
<h4 id="wsl-内无法访问网络"><a class="header" href="#wsl-内无法访问网络">WSL 内无法访问网络</a></h4>
<p>使用这个东西: <a href="https://github.com/sakai135/wsl-vpnkit">wsl-vpnkit</a></p>
<h3 id="自定义wsl安装位置"><a class="header" href="#自定义wsl安装位置">自定义wsl安装位置</a></h3>
<p>参考：https://zhuanlan.zhihu.com/p/263089007：</p>
<p>手动下载ubuntu：https://docs.microsoft.com/zh-cn/windows/wsl/install-manual</p>
<p>把appx的后缀改为.zip，然后解压到想要安装WSL的目录下，我们可以得到一些文件</p>
<p>双击红框框出的那个ubuntu.exe（其他发行版的话也有类似的程序）,等待一段时间就成功安装到当前目录啦~</p>
<p>需要注意的是安装目录的磁盘不能开<strong>压缩内容以便节省磁盘空间</strong>选项，否则会报错<code>0xc03a001a</code></p>
<p>可以右键<code>文件夹--&gt;属性--&gt;常规--&gt;高级</code>找到并关闭这个选项</p>
<h3 id="wsl扩展硬盘大小"><a class="header" href="#wsl扩展硬盘大小">wsl扩展硬盘大小</a></h3>
<p>参考：https://www.jianshu.com/p/2348dc7e9aef</p>
<h4 id="windows侧操作"><a class="header" href="#windows侧操作">windows侧操作</a></h4>
<p>首先关闭wsl（ <code>wsl --shutdown </code>）</p>
<p>管理员打开powershell切到wsl的安装位置（自定义安装位置参考自定义wsl安装位置）</p>
<p>找到wsl文件系统路径，应该是ext4.vhdx这个文件</p>
<p><img src="docs/Operation/Development_Environment/WIndows开发环境配置.assets/image.png" alt="img"></p>
<p>然后执行 diskpart 命令，之后会进入一个命令行操作界面，一次执行以下命令</p>
<pre><code class="language-powershell">Select vdisk file="&lt;pathToVHD&gt;"
expand vdisk maximum="&lt;sizeInMegaBytes&gt;"
</code></pre>
<p>其中 是vhdx文件路径，是更改后的大小，单位为MB（例如希望大小改为512G, 就是524288）</p>
<h4 id="wsl内操作"><a class="header" href="#wsl内操作">wsl内操作</a></h4>
<p>重新打开wsl（打开的时候需要等待一段时间，猜测可能是在重新load文件系统）</p>
<p>然后执行以下命令</p>
<pre><code class="language-bash">sudo mount -t devtmpfs none /dev
# 获取文件系统的设备名， 这里获得的是/dev/sdb
mount | grep ext4 
# resize2fs 是个命令工具，如果不存在则需要安装(apt-get install resize2fs)
sudo resize2fs /dev/sdb
</code></pre>
<p><img src="docs/Operation/Development_Environment/WIndows开发环境配置.assets/image-20210428004219480.png" alt="img"></p>
<p><img src="docs/Operation/Development_Environment/WIndows开发环境配置.assets/image-20210428004238650-1767761085094-6.png" alt="img"></p>
<p>成功！</p>
<h3 id="wls2-ubuntu安装systemd"><a class="header" href="#wls2-ubuntu安装systemd">WLS2 Ubuntu安装systemd</a></h3>
<p>https://zhuanlan.zhihu.com/p/180195635</p>
<p>安装</p>
<p><code>sudo apt install -y fontconfig daemonize</code></p>
<p>编辑/etc/profile，添加</p>
<pre><code class="language-bash">SYSTEMD_PID=$(ps -ef | grep '/lib/systemd/systemd --system-unit=basic.target$' | grep -v unshare | awk '{print $2}')

if [ -z "$SYSTEMD_PID" ]; then
   sudo /usr/bin/daemonize /usr/bin/unshare --fork --pid --mount-proc /lib/systemd/systemd --system-unit=basic.target
   SYSTEMD_PID=$(ps -ef | grep '/lib/systemd/systemd --system-unit=basic.target$' | grep -v unshare | awk '{print $2}')
fi

if [ -n "$SYSTEMD_PID" ] &amp;&amp; [ "$SYSTEMD_PID" != "1" ]; then
    exec sudo /usr/bin/nsenter -t $SYSTEMD_PID -a su - $LOGNAME
fi
</code></pre>
<p>编辑/etc/sudoers，添加</p>
<pre><code class="language-bash">%sudo ALL=(ALL) NOPASSWD: /usr/sbin/daemonize /usr/bin/unshare --fork --pid --mount-proc /lib/systemd/systemd --system-unit=basic.target
%sudo ALL=(ALL) NOPASSWD: /usr/bin/nsenter -t [0-9]* -a su - [a-zA-Z0-9]*
</code></pre>
<p>然后重启，最好检查</p>
<pre><code class="language-bash">source /etc/profile
systemctl -version
</code></pre>
<h2 id="windows-terminal"><a class="header" href="#windows-terminal">windows terminal</a></h2>
<h3 id="windows-terminal设置"><a class="header" href="#windows-terminal设置">windows terminal设置</a></h3>
<pre><code class="language-json">// This file was initially generated by Windows Terminal 1.3.2651.0
// It should still be usable in newer versions, but newer versions might have additional
// settings, help text, or changes that you will not see unless you clear this file
// and let us generate a new one for you.

// To view the default settings, hold "alt" while clicking on the "Settings" button.
// For documentation on these settings, see: https://aka.ms/terminal-documentation
{
    "$schema": "https://aka.ms/terminal-profiles-schema",

    "defaultProfile": "{61c54bbd-c2c6-5271-96e7-009a87ff44bf}",

    // You can add more global application settings here.
    // To learn more about global settings, visit https://aka.ms/terminal-global-settings

    // If enabled, selections are automatically copied to your clipboard.
    "copyOnSelect": false,

    // If enabled, formatted data is also copied to your clipboard
    "copyFormatting": false,

    // A profile specifies a command to execute paired with information about how it should look and feel.
    // Each one of them will appear in the 'New Tab' dropdown,
    //   and can be invoked from the commandline with `wt.exe -p xxx`
    // To learn more about profiles, visit https://aka.ms/terminal-profile-settings
    "profiles":
    {
        "defaults":
        {
            // Put settings here that you want to apply to all profiles.
        },
        "list":
        [
             
            {
                "guid": "{07b52e3e-de2c-5db4-bd2d-ba144ed6c273}",
                "hidden": false,
                "name": "Ubuntu-20.04",
                "source": "Windows.Terminal.Wsl"
            },
            {
                // Make changes here to the powershell.exe profile.
                "guid": "{61c54bbd-c2c6-5271-96e7-009a87ff44bf}",
                "name": "Windows PowerShell",
                "commandline": "powershell.exe",
                "hidden": false
            },
            {
                // Make changes here to the cmd.exe profile.
                "guid": "{0caa0dad-35be-5f56-a8ff-afceeeaa6101}",
                "name": "命令提示符",
                "commandline": "cmd.exe",
                "hidden": false
            },
            {
                "guid": "{b453ae62-4e3d-5e58-b989-0a998ec441b8}",
                "hidden": false,
                "name": "Azure Cloud Shell",
                "source": "Windows.Terminal.Azure"
            },
            {
                "guid": "{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}",
                "hidden": false,
                "name": "Ubuntu-18.04",
                "source": "Windows.Terminal.Wsl"
            }
        ]
    },

    // Add custom color schemes to this array.
    // To learn more about color schemes, visit https://aka.ms/terminal-color-schemes
    "schemes": [],

    // Add custom actions and keybindings to this array.
    // To unbind a key combination from your defaults.json, set the command to "unbound".
    // To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings
    "actions":
    [
        // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json.
        // These two lines additionally bind them to Ctrl+C and Ctrl+V.
        // To learn more about selection, visit https://aka.ms/terminal-selection
        { "command": {"action": "copy", "singleLine": false }, "keys": "ctrl+shift+c" },
        { "command": "paste", "keys": "ctrl+shift+v" },

        // Press Ctrl+Shift+F to open the search box
        { "command": "find", "keys": "ctrl+shift+f" },

        // Press Alt+Shift+D to open a new pane.
        // - "split": "auto" makes this pane open in the direction that provides the most surface area.
        // - "splitMode": "duplicate" makes the new pane use the focused pane's profile.
        // To learn more about panes, visit https://aka.ms/terminal-panes
        { "command": { "action": "splitPane", "split": "auto", "splitMode": "duplicate" }, "keys": "alt+shift+plus" },
        { "command": { "action": "switchToTab", "index": 0 }, "keys": "alt+1" },
        { "command": { "action": "switchToTab", "index": 1 }, "keys": "alt+2" },
        { "command": { "action": "switchToTab", "index": 2 }, "keys": "alt+3" },
        { "command": { "action": "switchToTab", "index": 3 }, "keys": "alt+4" },
        { "command": { "action": "switchToTab", "index": 4 }, "keys": "alt+5" },
        { "command": { "action": "switchToTab", "index": 5 }, "keys": "alt+6" },
        { "command": { "action": "switchToTab", "index": 6 }, "keys": "alt+7" },
        { "command": { "action": "switchToTab", "index": 7 }, "keys": "alt+8" },
        { "command": { "action": "switchToTab", "index": 8 }, "keys": "alt+9" }
    ]
}
</code></pre>
<h2 id="useful-tools"><a class="header" href="#useful-tools">Useful tools</a></h2>
<h3 id="alfred-平替"><a class="header" href="#alfred-平替">Alfred 平替</a></h3>
<p><a href="https://github.com/Wox-launcher/Wox">Wox</a>: A cross-platform launcher that simply works</p>
<p>基本可以满足需求:</p>
<ul>
<li>搜索应用/文件</li>
<li>剪切板历史以及搜索</li>
<li>自定义快捷命令</li>
</ul>
<h3 id="自定义快捷键"><a class="header" href="#自定义快捷键">自定义快捷键</a></h3>
<p><a href="https://github.com/microsoft/PowerToys">PowerToys</a>: Microsoft PowerToys is a collection of utilities that help you customize Windows and streamline everyday tasks</p>
<p>可以满足：</p>
<ul>
<li>搜索应用/文件</li>
<li>自定义任何快捷键（可以指定只在某个应用中启用）</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
